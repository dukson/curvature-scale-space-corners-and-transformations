package algorithms.util;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

/**
 * supporting class for a search algorithm to hold state of a node in a path,
 * specifically for the PerimeterFinderMemo.
 * 
 * @author nichole
 */
public class PathStep {

    // bit vector representing all nodes visited when instantiated
    private final int totalVisitedAtInstantiation;
    private final PairInt coords;
    private final Set<PairInt> nextSteps;
    // unmodifiable set holding all available moves when instantiated
    private final UnModifiableSet possibleStepsAtInstantiation;

    public PathStep(PairInt coordinates, Set<PairInt> availableMoves,
        int totalVisitedBitVector) {
        this.coords = coordinates;
        possibleStepsAtInstantiation = new UnModifiableSet(availableMoves);
        nextSteps = new HashSet<PairInt>(availableMoves);
        totalVisitedAtInstantiation = totalVisitedBitVector;
    }
    
    public PairInt getCoords() {
        return coords;
    }
    public Set<PairInt> getNextSteps() {
        return nextSteps;
    }
    
    public PathStep copy() {
        
        PathStep cp = new PathStep(coords,
            possibleStepsAtInstantiation.copyToModifiable(),
            totalVisitedAtInstantiation);
        
        cp.nextSteps.clear();
        
        cp.nextSteps.addAll(nextSteps);
        
        return cp;
    }

    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof PathStep)) {
            return false;
        }
        PathStep other = (PathStep) obj;
        if (!coords.equals(other.coords)) {
            return false;
        }
        if (totalVisitedAtInstantiation != other.totalVisitedAtInstantiation) {
            return false;
        }
        if (!possibleStepsAtInstantiation.equals(other.possibleStepsAtInstantiation)) {
            return false;
        }
        // compare available moves:
        if (other.nextSteps.size() != nextSteps.size()) {
            return false;
        }
        for (PairInt p : nextSteps) {
            if (!other.nextSteps.contains(p)) {
                return false;
            }
        }
        return true;
    }

    @Override
    public int hashCode() {
        //TODO: revisit.  this is auto-generated by NetBeans IDE
        int hash = 5;
        hash = 11 * hash + this.totalVisitedAtInstantiation;
        hash = 11 * hash + Objects.hashCode(this.coords);
        hash = 11 * hash + Objects.hashCode(this.nextSteps);
        hash = 11 * hash + Objects.hashCode(this.possibleStepsAtInstantiation);
        return hash;
    }
    
    public static class UnModifiableSet {
        private final Set<PairInt> set;
        public UnModifiableSet(Set<PairInt> uSet) {
            this.set = new HashSet<>(uSet);
        }
        public boolean contains(PairInt p) {
            return set.contains(p);
        }
        public int size() {
            return set.size();
        }
        public Set<PairInt> copyToModifiable() {
            return new HashSet<>(set);
        }

        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof UnModifiableSet)) {
                return false;
            }
            UnModifiableSet other = (UnModifiableSet)obj;
            if (other.set.size() != set.size()) {
                return false;
            }
            for (PairInt p : set) {
                if (!other.set.contains(p)) {
                    return false;
                }
            }
            return true;
        }

        @Override
        public int hashCode() {
            //TODO: revisit.  this is auto-generated by NetBeans IDE
            int hash = 5;
            hash = 29 * hash + Objects.hashCode(this.set);
            return hash;
        }
    }
}

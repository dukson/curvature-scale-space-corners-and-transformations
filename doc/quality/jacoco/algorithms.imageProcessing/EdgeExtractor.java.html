<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EdgeExtractor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">EdgeExtractor.java</span></div><h1>EdgeExtractor.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.util.PairIntArray;
import algorithms.util.PairInt;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Level;

/**
 * Edge extractor operates on an image that has already been reduced to 
 * single pixel width lines and extracts edges from it, attempting to make
 * the longest edges it can. 
 * 
 * 
 * @see AbstractEdgeExtractor

Edge extraction
    Local Methods:
        (1) DFS walk through connected pixel to form a sequence of pixels called
            an edge.
          
        (2) merge adjacent edges at the endpoints.

        (3) merge curves by closest points if the outlying points can be safely
            trimmed.
            
        (4) find edge endpoints which are separated from one another by a gap of
            one and fill in the gap while merging the edges.
        
        (5) remove edges shorter than a minimum length

 * @author nichole
 */
<span class="pc bpc" id="L39" title="1 of 2 branches missed.">public class EdgeExtractor extends AbstractEdgeExtractor {</span>
            
    /**
     * NOTE:  input should have a black (empty) background and edges should
     * have values &gt; 125 counts.  Edges should also have width of 1 and no larger.
     * 
     * @param input 
     */
    public EdgeExtractor(GreyscaleImage input) {
        
<span class="fc" id="L49">        super(input);</span>
<span class="fc" id="L50">    }</span>
    
    /**
     * NOTE:  input should have a black (empty) background and edges should
     * have values &gt; 125 counts.  Edges should also have width of 1 and no larger.
     * The guide image is used to alter the extracted edges back towards the
     * highest intensity pixels of the guide image.  The guide image is expected
     * to be the combined X and Y gradient image from earlier processing
     * stages.
     * 
     * @param input
     * @param anEdgeGuideImage
     */
    public EdgeExtractor(GreyscaleImage input, 
        final GreyscaleImage anEdgeGuideImage) {
        
<span class="nc" id="L66">        super(input, anEdgeGuideImage);</span>
<span class="nc" id="L67">    }</span>
    
    /**
     * this method is invoked by the super class after the DFS connect of
     * points in the image to make edges.  It merges the edges that have
     * adjacent endpoints.
     * It then looks for locations within the edges where it
     * can connect to other edges by trimming a small number of pixels between
     * them.
     * 
     * @return 
     */
    @Override
    public List&lt;PairIntArray&gt; findEdgesIntermediateSteps(List&lt;PairIntArray&gt; edges) {
        
<span class="nc" id="L82">        List&lt;PairIntArray&gt; output = mergeAdjacentEndPoints(edges);</span>
        
<span class="nc" id="L84">        log.log(Level.INFO, &quot;{0} edges after merge adjacent&quot;, </span>
<span class="nc" id="L85">            Integer.toString(output.size()));</span>
        
        // This helps to merge edges (that is extracted curves) at adjacent 
        // points that resemble an intersection of the lines, but it's not 
        // necessarily useful if only interested in corners and not inflection
        // points because the curvature is determined correctly 
        // whether the curves are merged or not.
        
<span class="nc" id="L93">        output = connectClosestPointsIfCanTrim(output);</span>
        
<span class="nc" id="L95">        log.info(output.size() + &quot; edges after connect closest&quot;);</span>
        
<span class="nc" id="L97">        output = fillInGaps(output);</span>
        
<span class="nc" id="L99">        log.log(Level.INFO, &quot;{0} edges after fill in gaps&quot;, </span>
<span class="nc" id="L100">            new Object[]{Integer.toString(output.size())});</span>
         
<span class="nc" id="L102">        return output;</span>
    }
 
    /**
     * merge edges adjacent end points of given edges.
     * For best results, make sure the edges were created from an image whose
     * lines were thinned to 1 pixel widths.
     * 
     * the runtime complexity is at best O(N).
    
     * @param edges
     * @return 
     */
    protected List&lt;PairIntArray&gt; mergeAdjacentEndPoints(
        List&lt;PairIntArray&gt; edges) {
        
<span class="fc" id="L118">        List&lt;PairIntArray&gt; output = new ArrayList&lt;PairIntArray&gt;();</span>
        
<span class="pc bpc" id="L120" title="1 of 4 branches missed.">        if (edges == null || edges.isEmpty()) {</span>
<span class="fc" id="L121">            return output;</span>
        }
        
        // 2 * O(N)
<span class="fc" id="L125">        Map&lt;PairInt, Integer&gt; endPointMap = createEndPointMap(edges);</span>
        
        // initialize the current endpoint information:
<span class="fc" id="L128">        int currentEdgeIdx = 0;</span>
        
<span class="fc" id="L130">        PairInt currentEndPoint = findStartingPoint(</span>
<span class="fc" id="L131">            new PairInt(edges.get(currentEdgeIdx).getX(0), </span>
<span class="fc" id="L132">            edges.get(currentEdgeIdx).getY(0)), endPointMap,</span>
            edges);
        
<span class="fc" id="L135">        currentEdgeIdx = endPointMap.get(currentEndPoint).intValue();</span>
        
<span class="fc" id="L137">        currentEndPoint = getOppositeEndPointOfEdge(currentEndPoint, </span>
<span class="fc" id="L138">            edges.get(currentEdgeIdx));</span>
                
<span class="fc" id="L140">        output.add(edges.get(currentEdgeIdx));</span>
     
<span class="fc" id="L142">        endPointMap.remove(currentEndPoint);</span>
<span class="fc" id="L143">        endPointMap.remove(getOppositeEndPointOfEdge(currentEndPoint, </span>
<span class="fc" id="L144">            edges.get(currentEdgeIdx)));</span>
        
<span class="fc" id="L146">        int[] dxs = new int[]{-1, -1,  0,  1, 1, 1, 0, -1};</span>
<span class="fc" id="L147">        int[] dys = new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};</span>
        
<span class="fc" id="L149">        List&lt;Integer&gt; foundEdgesIndexes = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L150">        List&lt;PairInt&gt; foundEndPoints = new ArrayList&lt;PairInt&gt;();</span>
        
        // 2 * O(N) * 8
<span class="fc bfc" id="L153" title="All 2 branches covered.">        while (!endPointMap.isEmpty()) {</span>
            
<span class="fc" id="L155">            int maxAdjEdgesIdx = -1;</span>
            
<span class="fc" id="L157">            int maxAdjEdgesN = Integer.MIN_VALUE;</span>
            
<span class="fc" id="L159">            PairInt maxAdjEdgesPoint = null;</span>
            
<span class="fc" id="L161">            foundEdgesIndexes.clear();</span>
<span class="fc" id="L162">            foundEndPoints.clear();         </span>
            
<span class="fc bfc" id="L164" title="All 2 branches covered.">            for (int nIdx = 0; nIdx &lt; dxs.length; nIdx++) {</span>
<span class="fc" id="L165">                int x = currentEndPoint.getX() + dxs[nIdx];</span>
<span class="fc" id="L166">                int y = currentEndPoint.getY() + dys[nIdx];</span>
                
<span class="fc" id="L168">                PairInt p = new PairInt(x, y);</span>
                
<span class="fc" id="L170">                Integer eIdx = endPointMap.get(p);</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">                if (eIdx != null) {</span>
<span class="fc" id="L172">                    foundEdgesIndexes.add(eIdx);</span>
<span class="fc" id="L173">                    foundEndPoints.add(p);</span>
<span class="fc" id="L174">                    int nPoints = edges.get(eIdx.intValue()).getN();</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">                    if (nPoints &gt; maxAdjEdgesN) {</span>
<span class="fc" id="L176">                        maxAdjEdgesN = nPoints;</span>
<span class="fc" id="L177">                        maxAdjEdgesIdx = eIdx.intValue();</span>
<span class="fc" id="L178">                        maxAdjEdgesPoint = p;</span>
                    }
                }
            }
            
<span class="fc bfc" id="L183" title="All 2 branches covered.">            if (!foundEndPoints.isEmpty()) {</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">                if (foundEndPoints.size() &gt; 1) {</span>
                    // this is a junction
                    
                    // add entry too junctionMap
<span class="fc" id="L188">                    Set&lt;PairInt&gt; values = new HashSet&lt;PairInt&gt;(foundEndPoints);</span>
                    
<span class="fc" id="L190">                    PairIntArray lastInOutput = output.get(output.size() - 1);</span>
<span class="fc" id="L191">                    int n = lastInOutput.getN();</span>
<span class="fc" id="L192">                    PairInt prevPoint = new PairInt(lastInOutput.getX(n - 2),</span>
<span class="fc" id="L193">                        lastInOutput.getY(n - 2));</span>
                    
<span class="fc" id="L195">                    values.add(prevPoint);</span>
                    
<span class="fc" id="L197">                    currentEdgeIdx = maxAdjEdgesIdx;</span>
                    
<span class="fc" id="L199">                    currentEndPoint = getOppositeEndPointOfEdge(</span>
<span class="fc" id="L200">                        maxAdjEdgesPoint, edges.get(currentEdgeIdx));</span>
                    
<span class="fc" id="L202">                } else {</span>
                    
<span class="fc" id="L204">                    currentEdgeIdx = foundEdgesIndexes.get(0);</span>
                    
<span class="fc" id="L206">                    currentEndPoint = getOppositeEndPointOfEdge(</span>
<span class="fc" id="L207">                        foundEndPoints.get(0), edges.get(currentEdgeIdx));                      </span>
                }
              
            } else {
                
<span class="fc" id="L212">                output.add(new PairIntArray());</span>
                
                // since the last edge has ended, pick any remaining in
                // endPointMap as the start of the next.
                // then invoke a method to follow the endpoint back to find
                // the true start
                
<span class="fc" id="L219">                Entry&lt;PairInt, Integer&gt; tmp = </span>
<span class="fc" id="L220">                    endPointMap.entrySet().iterator().next();</span>
                
<span class="fc" id="L222">                currentEndPoint = findStartingPoint(tmp.getKey(), endPointMap, </span>
                    edges);
                
<span class="fc" id="L225">                currentEdgeIdx = endPointMap.get(currentEndPoint).intValue();</span>
            }
                        
<span class="fc" id="L228">            appendToOutput(output, edges.get(currentEdgeIdx));</span>
     
<span class="fc" id="L230">            PairInt oppositeEndPoint = getOppositeEndPointOfEdge(currentEndPoint, </span>
<span class="fc" id="L231">                edges.get(currentEdgeIdx));</span>
            
<span class="fc" id="L233">            Integer v0 = endPointMap.remove(currentEndPoint);</span>
<span class="fc" id="L234">            Integer v1 = endPointMap.remove(oppositeEndPoint);</span>
<span class="pc bpc" id="L235" title="3 of 4 branches missed.">            assert(v0 != null);</span>
<span class="pc bpc" id="L236" title="3 of 4 branches missed.">            assert(v1 != null);</span>
<span class="fc" id="L237">        }</span>
      
<span class="fc" id="L239">        return output;</span>
    }
    
    protected Map&lt;PairInt, Integer&gt; createEndPointMap(List&lt;PairIntArray&gt;
        edges) {
        
<span class="fc" id="L245">        Map&lt;PairInt, Integer&gt; endPointMap = new HashMap&lt;PairInt, Integer&gt;();</span>
        
<span class="fc bfc" id="L247" title="All 2 branches covered.">        for (int idx = 0; idx &lt; edges.size(); idx++) {</span>
            
<span class="fc" id="L249">            PairIntArray edge = edges.get(idx);</span>
            
<span class="fc" id="L251">            int n = edge.getN();</span>
            
<span class="fc" id="L253">            PairInt start = new PairInt(edge.getX(0), edge.getY(0));</span>
            
<span class="fc" id="L255">            PairInt end = new PairInt(edge.getX(n - 1), edge.getY(n - 1));</span>
            
<span class="fc" id="L257">            endPointMap.put(start, Integer.valueOf(idx));</span>
            
<span class="fc" id="L259">            endPointMap.put(end, Integer.valueOf(idx));</span>
            
        }
        
<span class="fc" id="L263">        return endPointMap;</span>
    }
    
    /**
     * fill in gaps of '1' pixel
     * 
     * runtime complexity:
     *   2 * O(N_edges^2)
     * 
     * @param edges
     * @return 
     */
    protected List&lt;PairIntArray&gt; fillInGaps(List&lt;PairIntArray&gt;
        edges) {
            
        /*
        similar to the mergeAdjacentEndPoints:  
        compare end of uEdge to beginning of all others
        reverse uEdge and repeat
        revert reverse for next start
        */
      
<span class="fc" id="L285">        boolean[] removed = new boolean[edges.size()];</span>
        
<span class="fc" id="L287">        List&lt;PairIntArray&gt; output = new ArrayList&lt;PairIntArray&gt;();</span>
                
<span class="fc bfc" id="L289" title="All 2 branches covered.">        for (int i = 0; i &lt; edges.size(); i++) {</span>
            
<span class="fc bfc" id="L291" title="All 2 branches covered.">            if (removed[i]) {</span>
<span class="fc" id="L292">                continue;</span>
            }
            
<span class="fc" id="L295">            PairIntArray uEdge = edges.get(i);</span>
            
            // an extra iteration for reversing uEdge
<span class="fc bfc" id="L298" title="All 2 branches covered.">            for (int r = 0; r &lt; 2; r++) {</span>
                 
                // compare bottom of uEdge to top of vEdge

<span class="fc bfc" id="L302" title="All 2 branches covered.">                for (int j = 0; j &lt; edges.size(); j++) {</span>

<span class="fc bfc" id="L304" title="All 2 branches covered.">                    if (i == j) {</span>
<span class="fc" id="L305">                        continue;</span>
                    }
<span class="fc bfc" id="L307" title="All 2 branches covered.">                    if (removed[j]) {</span>
<span class="fc" id="L308">                        continue;</span>
                    }

<span class="fc" id="L311">                    PairIntArray vEdge = edges.get(j);</span>

                    // recalculate in case u has grown
<span class="fc" id="L314">                    int uX = uEdge.getX(uEdge.getN() - 1);</span>
<span class="fc" id="L315">                    int uY = uEdge.getY(uEdge.getN() - 1);</span>

<span class="fc" id="L317">                    int vX = vEdge.getX(0);</span>
<span class="fc" id="L318">                    int vY = vEdge.getY(0);</span>

<span class="fc" id="L320">                    int diffX = uX - vX;</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">                    if (diffX &lt; 0) {</span>
<span class="fc" id="L322">                        diffX *= -1;</span>
                    }

<span class="fc bfc" id="L325" title="All 2 branches covered.">                    if (diffX &gt; 2) {</span>
<span class="fc" id="L326">                        continue;</span>
                    }

<span class="fc" id="L329">                    int diffY = uY - vY;</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">                    if (diffY &lt; 0) {</span>
<span class="fc" id="L331">                        diffY *= -1;</span>
                    }

<span class="pc bpc" id="L334" title="1 of 2 branches missed.">                    if (diffY &gt; 2) {</span>
<span class="nc" id="L335">                        continue;</span>
                    }
                    
<span class="fc" id="L338">                    int gapX = (uX + vX)/2;</span>
<span class="fc" id="L339">                    int gapY = (uY + vY)/2;</span>
                                        
<span class="fc" id="L341">                    img.setValue(gapX, gapY, 255);</span>
                    
<span class="fc" id="L343">                    uEdge.add(gapX, gapY);</span>
                    
<span class="fc bfc" id="L345" title="All 2 branches covered.">                    for (int k = 0; k &lt; vEdge.getN(); k++) {</span>
<span class="fc" id="L346">                        uEdge.add(vEdge.getX(k), vEdge.getY(k));</span>
                    }

<span class="fc" id="L349">                    removed[j] = true;</span>

                    // have to restart the j iteration to re-compare terms
<span class="fc" id="L352">                    j = -1;</span>
                }
                
<span class="fc bfc" id="L355" title="All 2 branches covered.">                if (r == 0) {</span>
                    // just finished forward, start revers 
<span class="fc" id="L357">                    uEdge.reverse();</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">                } else if (r == 1) {</span>
                    // revert the array back to other direction
<span class="fc" id="L360">                    uEdge.reverse();</span>
                }
            }
        }
        
<span class="fc bfc" id="L365" title="All 2 branches covered.">        for (int i = 0; i &lt; edges.size(); i++) {</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">            if (!removed[i]) {</span>
<span class="fc" id="L367">                output.add(edges.get(i));</span>
            }
        }
        
<span class="fc" id="L371">        return output;</span>
    }
    
    /**
     * find the closest point between the curve0 and curve1 and return the
     * points in curve0XY and curve1XY along with the method return value
     * which is the separation.
     * 
     * runtime complexity:
     *    O(N_edge1 x N_edge2)
     * 
     * @param curve0 
     * @param curve1
     * @param curve0Idx output variable to hold index to the (x, y) of the point 
     * in curve0 which is closest to curve0
     * @param curve1Idx output variable to hold index to the (x, y) of the point 
     * in curve0 which is closest to curve1
     * @return the separation between the closest pair of points in curve0 and 
     *   curve1
     */
    protected double findClosestPair(PairIntArray curve0, PairIntArray curve1, 
        int[] curve0Idx, int[] curve1Idx) {
        
<span class="fc" id="L394">        int idx0 = -1;</span>
<span class="fc" id="L395">        int idx1 = -1;</span>
<span class="fc" id="L396">        double min = Double.MAX_VALUE;</span>
        
<span class="fc bfc" id="L398" title="All 2 branches covered.">        for (int i = 0; i &lt; curve0.getN(); i++) {</span>
<span class="fc" id="L399">            int x0 = curve0.getX(i);</span>
<span class="fc" id="L400">            int y0 = curve0.getY(i);</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">            for (int j = 0; j &lt; curve1.getN(); j++) {</span>
<span class="fc" id="L402">                int x1 = curve1.getX(j);</span>
<span class="fc" id="L403">                int y1 = curve1.getY(j);</span>
<span class="fc" id="L404">                int dx = x1 - x0;</span>
<span class="fc" id="L405">                int dy = y1 - y0;</span>
<span class="fc" id="L406">                double d = dx*dx + dy*dy;</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">                if (d &lt; min) {</span>
<span class="fc" id="L408">                    min = d;</span>
<span class="fc" id="L409">                    idx0 = i;</span>
<span class="fc" id="L410">                    idx1 = j;</span>
                }
            }
        }
        
<span class="fc" id="L415">        curve0Idx[0] = idx0;</span>
        
<span class="fc" id="L417">        curve1Idx[0] = idx1;</span>
        
<span class="fc" id="L419">        return Math.sqrt(min);</span>
    }
    
    /**
     * connect the closest points in edges if trimming the outliers does not
     * remove too many points nor add a discontinuity in either edge.
     * 
     * Runtime complexity:
     *      O(N_edge x ~N_edge x (N_edge to N_edge^2))
     * 
     * @param edges
     * @return 
     */
    protected List&lt;PairIntArray&gt; connectClosestPointsIfCanTrim(
        List&lt;PairIntArray&gt; edges) {
             
<span class="fc" id="L435">        double sqrtTwo = Math.sqrt(2) + 0.01;</span>
        //double gapOfOne = 2*Math.sqrt(2) + 0.01;
        
<span class="fc" id="L438">        int[] edge0Idx = new int[1];</span>
<span class="fc" id="L439">        int[] edge1Idx = new int[1];</span>
        
<span class="fc" id="L441">        boolean[] removed = new boolean[edges.size()];</span>
        
<span class="fc" id="L443">        List&lt;PairIntArray&gt; output = new ArrayList&lt;PairIntArray&gt;();</span>
        
<span class="fc bfc" id="L445" title="All 2 branches covered.">        for (int i = 0; i &lt; edges.size(); i++) {</span>
            
<span class="fc bfc" id="L447" title="All 2 branches covered.">            if (removed[i]) {</span>
<span class="fc" id="L448">                continue;</span>
            }
            
<span class="fc" id="L451">            PairIntArray edge0 = edges.get(i);</span>
            
<span class="fc bfc" id="L453" title="All 2 branches covered.">            for (int j = (i + 1); j &lt; edges.size(); j++) {</span>
                
<span class="fc bfc" id="L455" title="All 2 branches covered.">                if (removed[j]) {</span>
<span class="fc" id="L456">                    continue;</span>
                }
                
<span class="fc" id="L459">                PairIntArray edge1 = edges.get(j);</span>
                
                // RT: O(N_edge0 x N_edge1)
                
<span class="fc" id="L463">                double sep = findClosestPair(edge0, edge1, edge0Idx, edge1Idx);</span>

<span class="pc bpc" id="L465" title="1 of 2 branches missed.">                if (sep &lt; sqrtTwo) {</span>
                    
                    // RT: O(N_edge0) or O(N_edge1)
                    
                    // do not merge them if the points are not near the
                    // ends of the points sets.
<span class="fc" id="L471">                    float closestFrac0 = (float)edge0Idx[0]/(float)edge0.getN();</span>
                    
<span class="fc" id="L473">                    float closestFrac1 = (float)edge1Idx[0]/(float)edge1.getN();</span>
                    
<span class="pc bpc" id="L475" title="1 of 4 branches missed.">                    if (((closestFrac0 &gt; 0.07) &amp;&amp; (closestFrac0 &lt; 0.93))) {</span>
<span class="nc" id="L476">                        continue;</span>
                    }
<span class="pc bpc" id="L478" title="1 of 4 branches missed.">                    if (((closestFrac1 &gt; 0.07) &amp;&amp; (closestFrac1 &lt; 0.93))) {</span>
<span class="nc" id="L479">                        continue;</span>
                    }
                    
<span class="fc" id="L482">                    boolean closest0IsNearTop = ((float)(edge0Idx[0]/</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">                        (edge0.getN() - edge0Idx[0]))) &lt;= 0.5;</span>
                    
<span class="fc bfc" id="L485" title="All 2 branches covered.">                    if (closest0IsNearTop) {</span>
                        // if we trim the top, is remaining bottom connected?
<span class="fc" id="L487">                        boolean isConnected = isRangeConnected(edge0, </span>
<span class="fc" id="L488">                            edge0Idx[0], edge0.getN() - 1);</span>
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">                        if (!isConnected) {</span>
<span class="nc" id="L490">                            continue;</span>
                        }
<span class="fc" id="L492">                    } else {</span>
                        // if we trim the bottom, is remaining top connected?
<span class="fc" id="L494">                        boolean isConnected = isRangeConnected(edge0, 0, </span>
                            edge0Idx[0]);                      
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">                        if (!isConnected) {</span>
<span class="nc" id="L497">                            continue;</span>
                        }
                    }
                                            
<span class="fc" id="L501">                    boolean closest1IsNearTop = (</span>
                        ((float)edge1Idx[0]/
<span class="fc bfc" id="L503" title="All 2 branches covered.">                        (float)(edge1.getN() - edge1Idx[0]))) &lt;= 0.5;</span>
                    
<span class="fc bfc" id="L505" title="All 2 branches covered.">                    if (closest1IsNearTop) {</span>
                        // if we trim the top, is remaining bottom connected?
<span class="fc" id="L507">                        boolean isConnected = isRangeConnected(edge1, </span>
<span class="fc" id="L508">                            edge1Idx[0], edge1.getN() - 1);</span>
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">                        if (!isConnected) {</span>
<span class="nc" id="L510">                            continue;</span>
                        }
<span class="fc" id="L512">                    } else {</span>
                        // if we trim the bottom, is remaining top connected?
<span class="fc" id="L514">                        boolean isConnected = isRangeConnected(edge1, 0, </span>
                            edge1Idx[0]);                      
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">                        if (!isConnected) {</span>
<span class="nc" id="L517">                            continue;</span>
                        }
                    }
                    
                    // if here, then can trim outside the closest points in the
                    // edges and merge the edges into edge0, and remove edge1
                    
<span class="fc bfc" id="L524" title="All 2 branches covered.">                    if (closest0IsNearTop) {</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">                        if (edge0Idx[0] &gt; 0) {</span>
<span class="fc" id="L526">                            edge0.removeRange(0, edge0Idx[0] - 1);</span>
                        }
                    } else {
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">                        if (edge0Idx[0] &lt; (edge0.getN() - 1)) {</span>
<span class="fc" id="L530">                            edge0.removeRange(edge0Idx[0] + 1, edge0.getN() - 1);</span>
                        }
                    }
                    
                    //TODO:  could remove this step and adjust the add, but 
                    //       easier maintainence this way
<span class="fc bfc" id="L536" title="All 2 branches covered.">                    if (closest1IsNearTop) {</span>
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">                        if (edge1Idx[0] &gt; 0) {</span>
<span class="nc" id="L538">                            edge1.removeRange(0, edge1Idx[0] - 1);</span>
                        }
                    } else {
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">                        if (edge1Idx[0] &lt; (edge1.getN() - 1)) {</span>
<span class="nc" id="L542">                            edge1.removeRange(edge1Idx[0] + 1, edge1.getN() - 1);</span>
                        }
                    }
                    
<span class="fc bfc" id="L546" title="All 2 branches covered.">                    if (closest0IsNearTop) {</span>
                        // insert edge1 at top of edge0
<span class="fc" id="L548">                        edge0.insertSpaceAtTopOfArrays(edge1.getN());</span>
                        
                        // if edge1 closest is at bottom of it's edge, just add,
                        // else reverse then add
<span class="fc bfc" id="L552" title="All 2 branches covered.">                        if (closest1IsNearTop) {</span>
<span class="fc" id="L553">                            edge1.reverse();</span>
                        }

<span class="fc bfc" id="L556" title="All 2 branches covered.">                        for (int k = 0; k &lt; edge1.getN(); k++) {</span>
<span class="fc" id="L557">                            edge0.set(k, edge1.getX(k), edge1.getY(k));</span>
                        }
                    } else {
                        // append edge1 to bottom of edge0
                        
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">                        if (!closest1IsNearTop) {</span>
<span class="nc" id="L563">                            edge1.reverse();</span>
                        }

<span class="fc bfc" id="L566" title="All 2 branches covered.">                        for (int k = 0; k &lt; edge1.getN(); k++) {</span>
<span class="fc" id="L567">                            edge0.add(edge1.getX(k), edge1.getY(k));</span>
                        }
                    }
                  
<span class="fc" id="L571">                    removed[j] = true;</span>
                    
                    // have to restart the j iteration to re-compare terms
<span class="fc" id="L574">                    j = i;</span>
                }
            }
<span class="fc" id="L577">            output.add(edge0);</span>
        }
        
<span class="fc" id="L580">        return output;</span>
    }
    
    /**
     * check that points within index idxLo and idxHi, inclusive, are 
     * consecutively within 1 pixel of adjacent indexes.
     * @param edge
     * @param idxLo
     * @param idxHi
     * @return 
     */
    protected boolean isRangeConnected(PairIntArray edge, int idxLo, int idxHi) {
        
<span class="fc bfc" id="L593" title="All 2 branches covered.">        for (int i = (idxLo + 1); i &lt;= idxHi; i++) {</span>
<span class="fc" id="L594">            int x0 = edge.getX(i - 1);            </span>
<span class="fc" id="L595">            int x1 = edge.getX(i);</span>
<span class="fc" id="L596">            int diffX = x0 - x1;</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">            if (diffX &lt; 0) {</span>
<span class="fc" id="L598">                diffX *= -1;</span>
            }
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">            if (diffX &gt; 1) {</span>
<span class="nc" id="L601">                return false;</span>
            }
            
<span class="fc" id="L604">            int y0 = edge.getY(i - 1);</span>
<span class="fc" id="L605">            int y1 = edge.getY(i);</span>
<span class="fc" id="L606">            int diffY = y0 - y1;</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">            if (diffY &lt; 0) {</span>
<span class="fc" id="L608">                diffY *= -1;</span>
            }
<span class="fc bfc" id="L610" title="All 2 branches covered.">            if (diffY &gt; 1) {</span>
<span class="fc" id="L611">                return false;</span>
            }
        }
        
<span class="fc" id="L615">        return true;</span>
    }

    /**
     * Search endMap &quot;backwards&quot; to find the earliest match to the startPoint.
     * When a junction is found, choose the longest edge.
     * &lt;pre&gt;
     *           -- find 
     *             \
     *              \
     *               \           start
     *                \find     *point
     *             |---/-------||------|
     *       discard
     * &lt;/pre&gt;
     * @param startPoint
     * @param endPointMap
     * @param edges
     * @return 
     */
    protected PairInt findStartingPoint(PairInt startPoint, Map&lt;PairInt, Integer&gt; 
        endPointMap, List&lt;PairIntArray&gt; edges) {
        
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">        if (startPoint == null) {</span>
<span class="nc" id="L639">            throw new IllegalArgumentException(&quot;startPoint cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">        if (endPointMap == null) {</span>
<span class="nc" id="L642">            throw new IllegalArgumentException(&quot;endPointMap cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">        if (edges == null) {</span>
<span class="nc" id="L645">            throw new IllegalArgumentException(&quot;edges cannot be null&quot;);</span>
        }
        
<span class="fc" id="L648">        int[] dxs = new int[]{-1, -1,  0,  1, 1, 1, 0, -1};</span>
<span class="fc" id="L649">        int[] dys = new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};</span>
        
<span class="fc" id="L651">        PairInt originalStartPoint = startPoint;</span>
        
<span class="fc" id="L653">        PairInt lastStartPoint = startPoint;</span>
        
<span class="fc" id="L655">        PairInt currentStartPoint = startPoint;</span>
                
<span class="fc" id="L657">        Set&lt;PairInt&gt; visited = new HashSet&lt;PairInt&gt;();</span>
<span class="fc" id="L658">        visited.add(currentStartPoint);</span>
        
<span class="fc" id="L660">        int nIter = 0;</span>
        
<span class="fc bfc" id="L662" title="All 2 branches covered.">        while (currentStartPoint != null) {</span>
                        
<span class="pc bpc" id="L664" title="1 of 4 branches missed.">            if ((nIter &gt; 0) &amp;&amp; (lastStartPoint.equals(currentStartPoint))) {</span>
<span class="nc" id="L665">                break;</span>
            }
            
<span class="fc" id="L668">            int maxN = Integer.MIN_VALUE;</span>
<span class="fc" id="L669">            Integer maxNIndex = null;            </span>
<span class="fc" id="L670">            PairInt maxNPoint = null;</span>
            
<span class="fc bfc" id="L672" title="All 2 branches covered.">            for (int nIdx = 0; nIdx &lt; dxs.length; nIdx++) {</span>
                
<span class="fc" id="L674">                int x = currentStartPoint.getX() + dxs[nIdx];</span>
<span class="fc" id="L675">                int y = currentStartPoint.getY() + dys[nIdx];</span>
                
<span class="fc" id="L677">                PairInt p = new PairInt(x, y);</span>
                
<span class="fc" id="L679">                Integer eIndex = endPointMap.get(p);</span>
                
<span class="fc bfc" id="L681" title="All 2 branches covered.">                if (eIndex != null) {</span>
                    
<span class="fc" id="L683">                    PairIntArray pai = edges.get(eIndex.intValue());</span>
                    
<span class="fc" id="L685">                    int n = pai.getN();</span>
                    
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">                    if (n &gt; maxN) {</span>
                        
                        // the opposite end of this edge becomes
                        // our next potential currentStartPoint
<span class="fc" id="L691">                        PairInt reversed = getOppositeEndPointOfEdge(p, pai);</span>
                        
<span class="fc bfc" id="L693" title="All 2 branches covered.">                        if (visited.contains(reversed)) {</span>
                            // if this is a closed curve, return the original
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">                            if (reversed.equals(originalStartPoint)) {</span>
<span class="fc" id="L696">                                return originalStartPoint;</span>
                            }
                            continue;
                        }
    
<span class="fc" id="L701">                        maxN = n;</span>
<span class="fc" id="L702">                        maxNIndex = eIndex;</span>
<span class="fc" id="L703">                        maxNPoint = reversed;</span>
                    }
                }
            }
            
<span class="fc" id="L708">            lastStartPoint = currentStartPoint;</span>
            
<span class="fc bfc" id="L710" title="All 2 branches covered.">            if (maxNIndex == null) {</span>
<span class="fc" id="L711">                currentStartPoint = null;</span>
            } else {
                
<span class="fc" id="L714">                currentStartPoint = maxNPoint;</span>
        
<span class="fc" id="L716">                visited.add(currentStartPoint);</span>
                
                // if this is a closed curve, return the original value
<span class="pc bpc" id="L719" title="1 of 2 branches missed.">                if (currentStartPoint.equals(originalStartPoint)) {</span>
<span class="nc" id="L720">                    return originalStartPoint;</span>
                }
            }
            
<span class="fc" id="L724">            nIter++;</span>
<span class="fc" id="L725">        }</span>
                        
<span class="fc" id="L727">        return lastStartPoint;</span>
    }

    /**
     * append edge to output, reversing the edge if needed to minimize the 
     * distance between the last point in output and the first point 
     * appended from edge.
     * 
     * @param output
     * @param edge 
     */
    protected void appendToOutput(List&lt;PairIntArray&gt; output, PairIntArray edge) {
        
<span class="fc" id="L740">        PairIntArray lastOutputEdge = output.get(output.size() - 1);</span>
        
<span class="fc bfc" id="L742" title="All 2 branches covered.">        if (lastOutputEdge.getN() == 0) {</span>
<span class="fc" id="L743">            lastOutputEdge.addAll(edge);</span>
<span class="fc" id="L744">            return;</span>
        }
        
<span class="fc" id="L747">        int lastX = lastOutputEdge.getX(lastOutputEdge.getN() - 1);</span>
<span class="fc" id="L748">        int lastY = lastOutputEdge.getY(lastOutputEdge.getN() - 1);</span>
        
<span class="fc" id="L750">        int x0 = edge.getX(0);</span>
<span class="fc" id="L751">        int y0 = edge.getY(0);</span>
<span class="fc" id="L752">        int diffX0 = x0 - lastX;</span>
<span class="fc" id="L753">        int diffY0 = y0 - lastY;</span>
<span class="fc" id="L754">        long dist0Sq = (diffX0 * diffX0) + (diffY0 * diffY0);</span>
        
<span class="fc" id="L756">        int xn = edge.getX(edge.getN() - 1);</span>
<span class="fc" id="L757">        int yn = edge.getY(edge.getN() - 1);</span>
        
<span class="fc" id="L759">        int diffXn = xn - lastX;</span>
<span class="fc" id="L760">        int diffYn = yn - lastY;</span>
<span class="fc" id="L761">        long distnSq = (diffXn * diffXn) + (diffYn * diffYn);</span>
        
<span class="fc bfc" id="L763" title="All 2 branches covered.">        if (dist0Sq &gt; distnSq) {</span>
            // reverse
<span class="fc" id="L765">            PairIntArray rev = edge.copy();</span>
<span class="fc" id="L766">            rev.reverse();</span>
<span class="fc" id="L767">            lastOutputEdge.addAll(rev);</span>
<span class="fc" id="L768">        } else {</span>
<span class="fc" id="L769">            lastOutputEdge.addAll(edge);</span>
        }
<span class="fc" id="L771">    }</span>
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
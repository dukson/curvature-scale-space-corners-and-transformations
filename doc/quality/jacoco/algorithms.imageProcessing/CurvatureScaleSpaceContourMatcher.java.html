<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CurvatureScaleSpaceContourMatcher.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">CurvatureScaleSpaceContourMatcher.java</span></div><h1>CurvatureScaleSpaceContourMatcher.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.util.PairInt;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.logging.Logger;

/**
 * class to match the contours extracted from two images and match them.
 * 
 * Based upon the algorithm contained in
 * &lt;pre&gt;
 * IEEE 'TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE, VOL. PAMI-8, 
 * NO. 1. JANUARY 1986.  &quot;Scale-Based Description and Recognition of Planar 
 * Curves and Two-Dimensional Shapes&quot; by FARZIN MOKHTARIAN AND ALAN MACKWORTH
 * &lt;/pre&gt;
 * 
 * A small change was made to the calculation and use of shift.
 * 
 * In CurvatureScaleSpaceImageMaker:
 * Edges are extracted from an image and for the closed curves in those edges,
 * scale space maps are made.  inflection points are found in those maps.
 * The range of sigma for each curve's scale space maps are from the lowest 
 * sigma, increasing by a factor of sqrt(2) until a sigma where there are no 
 * more inflection points.
 * t vs sigma &quot;images&quot; are created and the contours are extracted from those.
 * 
 * This code accepts the contours from two different images and maps the first
 * image to the other using the contours. 
 * 
 * @author nichole
 */
public final class CurvatureScaleSpaceContourMatcher {
    
<span class="fc" id="L40">    protected Heap heap = null;</span>
    
    /**
     * the costs calculated here are small fractions, so they need to be
     * multiplied by a large constant for use with the Fibonacci heap
     * which uses type long for its key (key is where cost is stored).
     * using 1E12 here
     */
    protected final static long heapKeyFactor= 1000000000000l;
    
    protected List&lt;CurvatureScaleSpaceContour&gt; c1;
    
    protected List&lt;CurvatureScaleSpaceContour&gt; c2;
    
    protected Map&lt;Integer, List&lt;Integer&gt; &gt; curveIndexToC1;
    
    protected Map&lt;Integer, List&lt;Integer&gt; &gt; curveIndexToC2;
        
<span class="fc" id="L58">    private double solutionScale = Double.MAX_VALUE;</span>
    
<span class="fc" id="L60">    private double solutionShift = Double.MAX_VALUE;</span>
    
<span class="fc" id="L62">    private double solutionCost = Double.MAX_VALUE;</span>
    
<span class="fc" id="L64">    private List&lt;CurvatureScaleSpaceContour&gt; solutionMatchedContours1 = null;</span>
    
<span class="fc" id="L66">    private List&lt;CurvatureScaleSpaceContour&gt; solutionMatchedContours2 = null;</span>
    
<span class="fc" id="L68">    private final Logger log = Logger.getLogger(this.getClass().getName());</span>
        
<span class="fc" id="L70">    private boolean scalesSomeSmallerThanOne = false;</span>
    
    /**
     * constructor taking required contour lists as arguments.  note that the
     * contour lists should only be from one edge each.
     * (Note, it should be possible to find shadows in an image too using this 
     * on edges in same image).
     * 
     * constructor.  the creation of internal data structures in this method
     * has runtime complexity:
     * &lt;pre&gt;
     *   O(N) + O(N*lg_2(N)) + O(N_curves^2) + O(N_curves^3)
     * 
     *       where each curve has a number of contours.
     * 
     *       N = number of contours
     *       N_curve = number of encapsulating curves.  this number is smaller
     *                 than N.  
     * &lt;/pre&gt;
     */
<span class="fc" id="L90">    public CurvatureScaleSpaceContourMatcher() {</span>
<span class="fc" id="L91">    }</span>
    
    private void initializeVariables(final List&lt;CurvatureScaleSpaceContour&gt; contours1, 
        final List&lt;CurvatureScaleSpaceContour&gt; contours2) {
        
        // then use collections synchronized and LongestEdgeComparator to
        // sort the ordered list

<span class="fc" id="L99">        c1 = new ArrayList&lt;CurvatureScaleSpaceContour&gt;(contours1);</span>
        
<span class="fc" id="L101">        c2 = new ArrayList&lt;CurvatureScaleSpaceContour&gt;(contours2);</span>
        
<span class="fc" id="L103">        Collections.sort(c1, new DescendingSigmaComparator());</span>
        
<span class="fc" id="L105">        Collections.sort(c2, new DescendingSigmaComparator());</span>
        
<span class="fc" id="L107">        curveIndexToC1 = new HashMap&lt;Integer, List&lt;Integer&gt; &gt;();</span>
        
<span class="fc" id="L109">        curveIndexToC2 = new HashMap&lt;Integer, List&lt;Integer&gt; &gt;();</span>
        
<span class="fc bfc" id="L111" title="All 2 branches covered.">        for (int i = 0; i &lt; c1.size(); i++) {</span>
<span class="fc" id="L112">            CurvatureScaleSpaceContour contour = c1.get(i);            </span>
<span class="fc" id="L113">            Integer curveIdx = Integer.valueOf(contour.getEdgeNumber());</span>
<span class="fc" id="L114">            List&lt;Integer&gt; indexes = curveIndexToC1.get(curveIdx);</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">            if (indexes == null) {</span>
<span class="fc" id="L116">                indexes = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L117">                curveIndexToC1.put(curveIdx, indexes);</span>
            }
<span class="fc" id="L119">            indexes.add(Integer.valueOf(i));            </span>
        }
        
<span class="fc bfc" id="L122" title="All 2 branches covered.">        for (int i = 0; i &lt; c2.size(); i++) {</span>
<span class="fc" id="L123">            CurvatureScaleSpaceContour contour = c2.get(i);            </span>
<span class="fc" id="L124">            Integer curveIdx = Integer.valueOf(contour.getEdgeNumber());</span>
<span class="fc" id="L125">            List&lt;Integer&gt; indexes = curveIndexToC2.get(curveIdx);</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">            if (indexes == null) {</span>
<span class="fc" id="L127">                indexes = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L128">                curveIndexToC2.put(curveIdx, indexes);</span>
            }
<span class="fc" id="L130">            indexes.add(Integer.valueOf(i));            </span>
        }
        
<span class="fc" id="L133">        initializeHeapNodes();</span>
<span class="fc" id="L134">    }</span>
    
    /**
    &lt;pre&gt;
       (1) create a node for every possible pair of the tallest contour of
          each curve in c1 with the same in c2.
          
          Solve for kScale and dShift for each node:
              t2 = kScale * t1 + dShift
              sigma2 = kScale * sigma1
              
          The runtime complexity for (1) is O(N_curves^2).
         
       (2) initial costs:
           apply the transformation parameters to the tallest contours from
           each curve, using only one per curve.

           Note that the transformation may wrap around the image, that is
           the t values.
           
           The cost is the difference between the predicted location of the
           2nd node, that is the model location, and the actual location of the
           node.
            
           The cost is either the straight line distance between the peaks
           as a function of t and sigma, or it only includes the sigma
           differences.
           (the paper isn't clear)
           
            The runtime complexity for this (2) is 
    &lt;/pre&gt;
    */
    private void initializeHeapNodes() {
                
<span class="fc" id="L168">        heap = new Heap();</span>
        
        // (1)  create initial scale and translate nodes from all possible 
        // contour combinations
       
<span class="fc bfc" id="L173" title="All 2 branches covered.">        for (int index1 = 0; index1 &lt; c1.size(); index1++) {</span>
            
<span class="fc" id="L175">            CurvatureScaleSpaceContour contour1 = c1.get(index1);</span>
            
            // find this contour's place within the parent edge's contours
            // to correct shift due to wrapping around 1 to 0 or vice versa                
<span class="fc" id="L179">            float minT = Float.MAX_VALUE;</span>
<span class="fc" id="L180">            float maxT = Float.MIN_VALUE;</span>
<span class="fc" id="L181">            List&lt;Integer&gt; c1Indexes = curveIndexToC1.get(</span>
                Integer.valueOf(contour1.getEdgeNumber()));
<span class="fc bfc" id="L183" title="All 2 branches covered.">            for (int i = 0; i &lt; c1Indexes.size(); i++) {</span>
<span class="fc" id="L184">                int c1Idx = c1Indexes.get(i);</span>
<span class="fc" id="L185">                CurvatureScaleSpaceContour ei = c1.get(c1Idx);</span>
<span class="fc" id="L186">                float t = ei.getPeakScaleFreeLength();</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">                if (t &lt; minT) {</span>
<span class="fc" id="L188">                    minT = t;</span>
                }
<span class="fc bfc" id="L190" title="All 2 branches covered.">                if (t &gt; maxT) {</span>
<span class="fc" id="L191">                    maxT = t;</span>
                }
            }
<span class="fc bfc" id="L194" title="All 2 branches covered.">            boolean contour1IsLast = (contour1.getPeakScaleFreeLength() == maxT);</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            boolean contour1IsFirst = (contour1.getPeakScaleFreeLength() == minT);</span>
            
<span class="fc bfc" id="L197" title="All 2 branches covered.">            for (int index2 = 0; index2 &lt; c2.size(); index2++) {</span>
            
<span class="fc" id="L199">                CurvatureScaleSpaceContour contour2 = c2.get(index2);</span>
                
                // find this contour's place within the parent edge's contours
                // to correct shift due to wrapping around 1 to 0 or vice versa                
<span class="fc" id="L203">                minT = Float.MAX_VALUE;</span>
<span class="fc" id="L204">                maxT = Float.MIN_VALUE;</span>
                for (Integer i
<span class="fc bfc" id="L206" title="All 2 branches covered.">                    : curveIndexToC2.get(Integer.valueOf(contour2.getEdgeNumber()))) {</span>
<span class="fc" id="L207">                    CurvatureScaleSpaceContour ei = c2.get(i.intValue());</span>
<span class="fc" id="L208">                    float t = ei.getPeakScaleFreeLength();</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">                    if (t &lt; minT) {</span>
<span class="fc" id="L210">                        minT = t;</span>
                    }
<span class="fc bfc" id="L212" title="All 2 branches covered.">                    if (t &gt; maxT) {</span>
<span class="fc" id="L213">                        maxT = t;</span>
                    }
<span class="fc" id="L215">                }</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">                boolean contour2IsLast = (contour2.getPeakScaleFreeLength() == maxT);</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">                boolean contour2IsFirst = (contour2.getPeakScaleFreeLength() == minT);</span>
                
<span class="fc" id="L219">                TransformationPair obj = new TransformationPair(index1, index2);</span>
                
                /*
                t2 = kScale * t1 + dShift
                sigma2 = kScale * sigma1
                */
                
<span class="fc" id="L226">                double scale = contour2.getPeakSigma()/contour1.getPeakSigma();</span>
                
                // tolerance for within range of '1'?
<span class="fc bfc" id="L229" title="All 2 branches covered.">                if ((scale + 0.05) &lt; 1) {</span>
                    // cannot match for scale &lt; 1 because cost function could
                    // prefer smaller sigma peaks that were not good matches.
<span class="fc" id="L232">                    scalesSomeSmallerThanOne = true;</span>
<span class="fc" id="L233">                    continue;</span>
                }
                
<span class="fc" id="L236">                double shift = contour2.getPeakScaleFreeLength() -</span>
                    (contour1.getPeakScaleFreeLength() * scale);
                
                /*
                correct for wrapping around the scale free axis
                */
<span class="fc bfc" id="L242" title="All 4 branches covered.">                if (contour1IsLast &amp;&amp; contour2IsFirst) {</span>
<span class="fc" id="L243">                    shift = (1 - contour1.getPeakScaleFreeLength()) +</span>
                        contour2.getPeakScaleFreeLength();
<span class="fc bfc" id="L245" title="All 4 branches covered.">                } else if (contour1IsFirst &amp;&amp; contour2IsLast) {</span>
<span class="fc" id="L246">                    shift = -1 * (contour1.getPeakScaleFreeLength() +</span>
                        (1 - contour2.getPeakScaleFreeLength()));
                }
                
<span class="fc" id="L250">                obj.setScale(scale);</span>
                
<span class="fc" id="L252">                obj.setShift(shift);</span>
                
<span class="fc" id="L254">                List&lt;CurvatureScaleSpaceContour&gt; visited = new </span>
                    ArrayList&lt;CurvatureScaleSpaceContour&gt;();
<span class="fc" id="L256">                visited.add(contour1);</span>
<span class="fc" id="L257">                visited.add(contour2);</span>
                
<span class="fc" id="L259">                NextContour nc = new NextContour(c1, true, curveIndexToC1,</span>
                    visited);
<span class="fc" id="L261">                nc.addMatchedContours(contour1, contour2);</span>
                
<span class="fc" id="L263">                obj.setNextContour(nc);</span>
                
<span class="fc" id="L265">                double cost = 0;</span>
                
                //(2) calc cost: apply to tallest contours from each curve
                
<span class="fc" id="L269">                Iterator&lt;Entry&lt;Integer, List&lt;Integer&gt; &gt; &gt; iter = </span>
                    curveIndexToC1.entrySet().iterator();
                
<span class="fc bfc" id="L272" title="All 2 branches covered.">                while (iter.hasNext()) {</span>
                
<span class="fc" id="L274">                    List&lt;Integer&gt; indexes = iter.next().getValue();</span>
            
<span class="fc" id="L276">                    int index1s = indexes.get(0);</span>
                    
<span class="fc" id="L278">                    CurvatureScaleSpaceContour contour1s = c1.get(index1s);</span>
                    
                    while (nc.getMatchedContours1().contains(contour1s)
<span class="fc bfc" id="L281" title="All 4 branches covered.">                        &amp;&amp; ((index1s + 1) &lt; c1.size())) {</span>
<span class="fc" id="L282">                        index1s++;</span>
<span class="fc" id="L283">                        contour1s = c1.get(index1s);</span>
                    }
<span class="fc bfc" id="L285" title="All 2 branches covered.">                    if (nc.getMatchedContours1().contains(contour1s)) {</span>
<span class="fc" id="L286">                        continue;</span>
                    }
                                                            
                    /*
                    t2 = kScale * t1 + dShift
                    sigma2 = kScale * sigma1
                    */
<span class="fc" id="L293">                    double sigma2 = scale * contour1s.getPeakSigma();</span>
<span class="fc" id="L294">                    double t2 = (scale * contour1s.getPeakScaleFreeLength()) </span>
                        + shift;
                    //double t2 = contour1s.getPeakScaleFreeLength() + shift;
<span class="fc bfc" id="L297" title="All 2 branches covered.">                    if (t2 &lt; 0) {</span>
<span class="fc" id="L298">                        t2 = 1 + t2;</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">                    } else if (t2 &gt; 1) {</span>
<span class="fc" id="L300">                        t2 = t2 - 1;</span>
                    }
                    
<span class="fc" id="L303">                    CurvatureScaleSpaceContour contour2s =</span>
                        findMatchingC2(contour1s.getEdgeNumber(),
                        sigma2, t2, nc);
                 
<span class="fc bfc" id="L307" title="All 2 branches covered.">                    if (contour2s != null) {</span>
<span class="fc" id="L308">                        nc.addMatchedContours(contour1s, contour2s);                   </span>
                    }
                    
<span class="fc" id="L311">                    double cost2 = calculateCost(contour2s, sigma2, t2);                    </span>

<span class="fc" id="L313">                    cost += cost2;</span>
<span class="fc" id="L314">                }</span>
                
                /*
                Penalty for starting a match from a peak which is not the max
                height peak for the edge:
                [last paragraph, section IV. A. of Mokhtarian &amp; Macworth 1896]
                &quot;Since it is desirable to find a match corresponding to the 
                coarse features of the curves, there is a penalty associated 
                with starting a match with a small contour.  
                This penalty is a linear function of the difference in height
                of that contour and the tallest contour of the same scale space
                image and is added to the cost of the match computed when a node
                is created.
                */
                /*if (!isTallestPeakInEdge1) {
                    
                    int c1Idx = curveIndexToC1.get(
                        Integer.valueOf(contour1.getEdgeNumber()))
                        .get(0).intValue();
                    
                    CurvatureScaleSpaceContour ei = c1.get(c1Idx);
                    
                    double penalty = ei.getPeakSigma() - contour1.getPeakSigma();
                    
                    cost += penalty;
                }*/
<span class="fc" id="L340">                double penalty = c1.get(0).getPeakSigma() </span>
                    - contour1.getPeakSigma();
<span class="fc" id="L342">                cost += penalty;</span>
                
<span class="fc" id="L344">                long costL = (long)(cost * heapKeyFactor);</span>
                
<span class="fc" id="L346">                HeapNode node = new HeapNode(costL);</span>
                
<span class="fc" id="L348">                node.setData(obj);</span>
                
<span class="fc" id="L350">                heap.insert(node);</span>
            }
        }
<span class="fc" id="L353">    }</span>
    
    /**
     * get the curvature scale space images factor of scale between the
     * first set of contours and the second set.
     * @return 
     */
    public double getSolvedScale() {
<span class="fc" id="L361">        return solutionScale;</span>
    }
    
    /**
     * get the curvature scale space images shift between the
     * first set of contours and the second set.
     * @return 
     */
    public double getSolvedShift() {
<span class="fc" id="L370">        return solutionShift;</span>
    }
    
    /**
     * get the curvature scale space images shift between the
     * first set of contours and the second set.
     * @return 
     */
    public double getSolvedCost() {
<span class="fc" id="L379">        return solutionCost;</span>
    }
    
     /**
     * match contours from the first list to the second.  the best scale and
     * shifts between the contour lists can be retrieved with getSolvedScale()
     * and getSolvedShift().  if a solution was found, returns true, else
     * returns false.
     * @param contours1
     * @param contours2
     * @return 
     */
    public boolean matchContours(List&lt;CurvatureScaleSpaceContour&gt; contours1, 
        List&lt;CurvatureScaleSpaceContour&gt; contours2) {
        
<span class="fc" id="L394">        initializeVariables(contours1, contours2);</span>
                
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (heap.n == 0) {            </span>
<span class="fc" id="L397">            return swapOrderAndMatchContours();            </span>
        }
        
<span class="fc" id="L400">        matchContours();</span>
        
<span class="fc bfc" id="L402" title="All 2 branches covered.">        if (!scalesSomeSmallerThanOne) {</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">            if (solutionScale &lt; Double.MAX_VALUE) {</span>
<span class="fc" id="L404">                return true;</span>
            } else {
<span class="nc" id="L406">                return false;</span>
            }
        }
        
        // else, some scales were smaller than one, so swap and try again
        // and return the best solution,
        // while also swapping the order back
        
<span class="fc" id="L414">        double origOrderScale = solutionScale;</span>
<span class="fc" id="L415">        double origOrderShift = solutionShift;</span>
<span class="fc" id="L416">        double origOrderCost = solutionCost;</span>

<span class="fc" id="L418">        List&lt;CurvatureScaleSpaceContour&gt; origOrderC1 = </span>
            new ArrayList&lt;CurvatureScaleSpaceContour&gt;(c1);
<span class="fc" id="L420">        List&lt;CurvatureScaleSpaceContour&gt; origOrderC2 = </span>
            new ArrayList&lt;CurvatureScaleSpaceContour&gt;(c2);

<span class="fc" id="L423">        Map&lt;Integer, List&lt;Integer&gt; &gt; origOrderCurveIndexToC1 =</span>
            new HashMap&lt;Integer, List&lt;Integer&gt; &gt;(curveIndexToC1);

<span class="fc" id="L426">        Map&lt;Integer, List&lt;Integer&gt; &gt; origOrderCurveIndexToC2 =</span>
            new HashMap&lt;Integer, List&lt;Integer&gt; &gt;(curveIndexToC2);
            
<span class="fc" id="L429">        List&lt;CurvatureScaleSpaceContour&gt; origOrderSolutionMatchedContours1 = </span>
            new ArrayList&lt;CurvatureScaleSpaceContour&gt;(
            solutionMatchedContours1);

<span class="fc" id="L433">        List&lt;CurvatureScaleSpaceContour&gt; origOrderSolutionMatchedContours2 =</span>
            new ArrayList&lt;CurvatureScaleSpaceContour&gt;(
            solutionMatchedContours2);
    
<span class="fc" id="L437">        initializeVariables(contours2, contours1);</span>
        
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">        if (heap.n &gt; 0) {</span>
<span class="fc" id="L440">            matchContours();</span>
        }
          
        // compare solutions and re-order the variables
        
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">        if (solutionScale == Double.MAX_VALUE) {</span>
            
<span class="nc" id="L447">            log.info(&quot;the first solution was the best&quot;);</span>
            
<span class="nc" id="L449">            solutionScale = origOrderScale;</span>
<span class="nc" id="L450">            solutionShift = origOrderShift;</span>
<span class="nc" id="L451">            solutionCost = origOrderCost;</span>
            
        } else {
            
            /*
            compare the solutions.  
                number of matches and cost...
            TODO: retain both solutions to determine best with the refinement
            using edges?
            */
            
<span class="fc" id="L462">            double normalizedCost1 = origOrderCost/</span>
                (double)origOrderSolutionMatchedContours1.size();

<span class="fc" id="L465">            double normalizedCost2 = solutionCost/</span>
                (double)solutionMatchedContours2.size();
            
<span class="fc" id="L468">            StringBuilder sb = new StringBuilder(&quot;first solution:\n&quot;);</span>
<span class="fc" id="L469">            sb.append(String.format(&quot; cost=%f  nMatched1=%d  normalizedCost=%f\n&quot;</span>
                , origOrderCost, origOrderSolutionMatchedContours1.size(), 
                normalizedCost1));
<span class="fc" id="L472">            sb.append(String.format(&quot; scale=%f  shift=%f\n&quot;, origOrderScale,</span>
                origOrderShift));
<span class="fc" id="L474">            log.info(sb.toString());</span>
            
<span class="fc" id="L476">            sb = new StringBuilder(&quot;second solution:\n&quot;);</span>
<span class="fc" id="L477">            sb.append(String.format(&quot; cost=%f  nMatched1=%d  normalizedCost=%f\n&quot;</span>
                , solutionCost, solutionMatchedContours2.size(), 
                normalizedCost2));
<span class="fc" id="L480">            sb.append(String.format(&quot; scale=%f  shift=%f\n&quot;, solutionScale,</span>
                solutionShift));
<span class="fc" id="L482">            log.info(sb.toString());</span>

            
<span class="fc bfc" id="L485" title="All 2 branches covered.">            if (normalizedCost2 &lt; normalizedCost1) {</span>
<span class="fc" id="L486">                solutionScale = 1./solutionScale;</span>
<span class="fc" id="L487">                solutionShift = 1. - solutionShift;</span>
                
<span class="fc" id="L489">                List&lt;CurvatureScaleSpaceContour&gt; swap3 = solutionMatchedContours1;</span>
<span class="fc" id="L490">                solutionMatchedContours1 = solutionMatchedContours2;</span>
<span class="fc" id="L491">                solutionMatchedContours2 = swap3;        </span>
<span class="fc" id="L492">            } else {</span>
<span class="fc" id="L493">                solutionScale = origOrderScale;</span>
<span class="fc" id="L494">                solutionShift = origOrderShift;</span>
                
<span class="fc" id="L496">                solutionMatchedContours1 = origOrderSolutionMatchedContours1;</span>
<span class="fc" id="L497">                solutionMatchedContours2 = origOrderSolutionMatchedContours2;</span>
            }
        }
                            
<span class="fc" id="L501">        log.info(&quot;have solution.  swapping the datasets back and inverting&quot;</span>
            + &quot; the solution for reference frame 1 to reference frame 2&quot;);

<span class="fc" id="L504">        List&lt;CurvatureScaleSpaceContour&gt; swap = c1;</span>
<span class="fc" id="L505">        c1 = c2;</span>
<span class="fc" id="L506">        c2 = swap;</span>
<span class="fc" id="L507">        Map&lt;Integer, List&lt;Integer&gt; &gt; swap2 = curveIndexToC1;</span>
<span class="fc" id="L508">        curveIndexToC1 = curveIndexToC2;</span>
<span class="fc" id="L509">        curveIndexToC2 = swap2;</span>
        
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">        if (solutionScale &lt; Double.MAX_VALUE) {</span>
<span class="fc" id="L512">            return true;</span>
        } else {
<span class="nc" id="L514">            return false;</span>
        }
    }
    
    private boolean swapOrderAndMatchContours() {
        
        // swap the order of datasets and try again.
<span class="fc" id="L521">        log.info(&quot;initialization resulted in 0 nodes, presumably due to &quot;</span>
            + &quot; scale &lt; 0, so swapping the order and trying again.&quot;);

<span class="fc" id="L524">        List&lt;CurvatureScaleSpaceContour&gt; contours1 = </span>
            new ArrayList&lt;CurvatureScaleSpaceContour&gt;(c1);

<span class="fc" id="L527">        List&lt;CurvatureScaleSpaceContour&gt; contours2 = </span>
            new ArrayList&lt;CurvatureScaleSpaceContour&gt;(c2);

<span class="fc" id="L530">        initializeVariables(contours2, contours1);</span>
        
<span class="fc" id="L532">        matchContours();</span>
        
<span class="fc" id="L534">        log.info(&quot;have solution.  swapping the datasets back and inverting&quot;</span>
            + &quot; the solution for reference frame 1 to reference frame 2&quot;);
        
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">        boolean solved = (solutionScale &lt; Double.MAX_VALUE);</span>
        
<span class="fc" id="L539">        List&lt;CurvatureScaleSpaceContour&gt; swap = c1;</span>
<span class="fc" id="L540">        c1 = c2;</span>
<span class="fc" id="L541">        c2 = swap;</span>
<span class="fc" id="L542">        Map&lt;Integer, List&lt;Integer&gt;&gt; swap2 = curveIndexToC1;</span>
<span class="fc" id="L543">        curveIndexToC1 = curveIndexToC2;</span>
<span class="fc" id="L544">        curveIndexToC2 = swap2;</span>
<span class="fc" id="L545">        List&lt;CurvatureScaleSpaceContour&gt; swap3 = solutionMatchedContours1;</span>
<span class="fc" id="L546">        solutionMatchedContours1 = solutionMatchedContours2;</span>
<span class="fc" id="L547">        solutionMatchedContours2 = swap3;</span>
<span class="fc" id="L548">        solutionScale = 1. / solutionScale;</span>
<span class="fc" id="L549">        solutionShift = 1. - solutionShift;</span>
        
<span class="fc" id="L551">        return solved;</span>
    }

    /**
     * match contours from the first list to the second.  the best scale and
     * shifts between the contour lists can be retrieved with getSolvedScale()
     * and getSolvedShift().  if a solution was found, returns true, else
     * returns false.
     * @return 
     */
    private void matchContours() {
        
<span class="fc" id="L563">        solutionShift = Double.MAX_VALUE;</span>
<span class="fc" id="L564">        solutionScale = Double.MAX_VALUE;</span>
<span class="fc" id="L565">        solutionCost = Double.MAX_VALUE;</span>
        
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">        if (heap.n == 0) {</span>
<span class="nc" id="L568">            return;</span>
        }
        
        // use a specialization of A* algorithm to apply transformation to 
        // contours for best cost solutions (does not compute all possible 
        // solutions).
<span class="fc" id="L574">        HeapNode minCost = solve();</span>
        
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">        if (minCost == null) {</span>
<span class="nc" id="L577">            return;</span>
        }
        
<span class="fc" id="L580">        TransformationPair obj = (TransformationPair)minCost.getData();</span>
        
<span class="fc" id="L582">        float shift = (float)obj.getShift();</span>
<span class="fc" id="L583">        float scale = (float)obj.getScale();</span>
     
<span class="fc" id="L585">        solutionShift = shift;</span>
<span class="fc" id="L586">        solutionScale = scale;</span>
<span class="fc" id="L587">        solutionCost = (double)(minCost.getKey()/heapKeyFactor);</span>
  
<span class="fc" id="L589">        NextContour nc = obj.getNextContour();</span>
                
<span class="fc" id="L591">        solutionMatchedContours1 = nc.getMatchedContours1();</span>
        
<span class="fc" id="L593">        solutionMatchedContours2 = nc.getMatchedContours2();</span>
        
<span class="fc" id="L595">    }</span>
    
    public List&lt;CurvatureScaleSpaceContour&gt; getSolutionMatchedContours1() {
<span class="fc" id="L598">        return solutionMatchedContours1;</span>
    }
    
    public List&lt;CurvatureScaleSpaceContour&gt; getSolutionMatchedContours2() {
<span class="fc" id="L602">        return solutionMatchedContours2;</span>
    }
    
    /**
       a specialization of the A* search pattern is used to refine the initial
       solution of best parameters.
       The current best solution is extracted from the min heap as the 
       min cost node.

       The &quot;neighbor&quot; to be visited is a candidate contour from list 1,
       chosen from contours not yet searched for it.  There are rules for 
       selecting the candidate contour.
       The cost of the mid cost node is modified by the results of the 
       application of the transformation parameters to the candidate contour.
        
       The process is repeated until there are no more admissable contours
       for an extracted min cost node.
      
     * @return 
     */
    private HeapNode solve() {
                
<span class="fc" id="L624">        HeapNode u = heap.extractMin();</span>
        
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">        while (u != null) {</span>
            
<span class="fc" id="L628">            TransformationPair obj = (TransformationPair)u.getData();</span>
        
<span class="fc" id="L630">            NextContour nc = obj.getNextContour();</span>
            
<span class="fc" id="L632">            CurvatureScaleSpaceContour c = c1.get(obj.getContourIndex1());</span>
<span class="fc" id="L633">            int curveIndex = c.getEdgeNumber();</span>
            
<span class="fc" id="L635">            CurvatureScaleSpaceContour contour1s = </span>
                nc.findTallestContourWithinAScaleSpace(curveIndex);
     
<span class="pc bpc" id="L638" title="1 of 4 branches missed.">            if ((contour1s == null) || </span>
                nc.getMatchedContours1().contains(contour1s)) {
                
                //TODO: refactor to improve handling of these indexes to remove
                // possibilities of using them incorrectly
                
<span class="fc" id="L644">                int contourIndex = nc.origContours.indexOf(c);</span>
                
<span class="fc" id="L646">                PairInt target = new PairInt(curveIndex, contourIndex);</span>
                
<span class="fc" id="L648">                contour1s = nc.findTheNextSmallestUnvisitedSibling(target);</span>
                
            }
            
<span class="fc bfc" id="L652" title="All 2 branches covered.">            if (contour1s == null) {                </span>
<span class="fc" id="L653">                return u;</span>
            }
            
<span class="fc" id="L656">            float shift = (float)obj.getShift();</span>
<span class="fc" id="L657">            float scale = (float)obj.getScale();</span>
            
            /*
            t2 = kScale * t1 + dShift
            sigma2 = kScale * sigma1
            */
<span class="fc" id="L663">            double sigma2 = scale * contour1s.getPeakSigma();</span>
<span class="fc" id="L664">            double t2 = (scale * contour1s.getPeakScaleFreeLength()) + shift;</span>
            //double t2 = contour1s.getPeakScaleFreeLength() + shift;
<span class="fc bfc" id="L666" title="All 2 branches covered.">            if (t2 &lt; 0) {</span>
<span class="fc" id="L667">                t2 = 1 + t2;</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">            } else if (t2 &gt; 1) {</span>
<span class="fc" id="L669">                t2 = t2 - 1;</span>
            }

<span class="fc" id="L672">            CurvatureScaleSpaceContour contour2s</span>
                = findMatchingC2(contour1s.getEdgeNumber(), sigma2, t2, nc);

<span class="fc bfc" id="L675" title="All 2 branches covered.">            if (contour2s != null) {</span>
<span class="fc" id="L676">                nc.addMatchedContours(contour1s, contour2s);</span>
            }
            
<span class="fc" id="L679">            double cost2 = calculateCost(contour2s, sigma2, t2);</span>

            /*
            NOTE: Not sure about applying this penalty for this cost.  
            Empirically validating with tests currently...
            [last paragraph, section IV. A. of Mokhtarian &amp; Macworth 1896]
            &quot;Since it is desirable to find a match corresponding to the coarse
            features of the curves, there is a penalty associated with starting
            a match with a small contour.  
            This penalty is a linear function of the difference in height
            of that contour and the tallest contour of the same scale space
            image and is added to the cost of the match computed when a node
            is created.
            */
<span class="fc" id="L693">            double penalty = c1.get(0).getPeakSigma() </span>
                - contour1s.getPeakSigma();
            //cost2 += penalty;
            
<span class="fc" id="L697">            u.setData(obj);</span>
            
<span class="fc" id="L699">            u.setKey(u.getKey() + (long)(cost2 * heapKeyFactor));</span>
            
<span class="fc" id="L701">            heap.insert(u);</span>
            
<span class="fc" id="L703">            u = heap.extractMin();</span>
<span class="fc" id="L704">        }</span>
        
<span class="nc" id="L706">        return u;</span>
    }
    
    /**
     * calculate the cost as the as the straight line difference between
     * the closest found contour and the model's sigma and peak.
     * @param contour
     * @param sigma
     * @param scaleFreeLength
     * @return 
     */
    private double calculateCost(CurvatureScaleSpaceContour contour, 
        double sigma, double scaleFreeLength) {
        
<span class="fc bfc" id="L720" title="All 2 branches covered.">        if (contour == null) {</span>
<span class="fc" id="L721">            return sigma;</span>
        }
        /*
        It's not clear whether the cost should include the scale free length
        and sigma or just sigma.
        From Mokhatarian &amp; Mackworth 1986, Section IV, middle of column 1:
        &quot;The average distance between two contours is the average of the 
        distances between the peaks, the right branches, and the left branches. 
        The cost of matching two contours is defined to be the averaged 
        distance between them after one of them has been transformed.&quot;
        */

<span class="fc" id="L733">        double ds = sigma - contour.getPeakSigma();</span>
       
<span class="fc" id="L735">        double dt = scaleFreeLength - contour.getPeakScaleFreeLength();</span>
<span class="fc" id="L736">        double len = Math.sqrt(ds*ds + dt*dt);</span>
        
<span class="fc" id="L738">        return len;</span>
    }

    private CurvatureScaleSpaceContour findMatchingC2(
        int edgeNumber1, double sigma2, double t2, NextContour nc) {
        
<span class="fc" id="L744">        int expectedEdgeNumber2 = nc.getMatchedEdgeNumber2(edgeNumber1);</span>

        int idx2;
        
<span class="fc bfc" id="L748" title="All 2 branches covered.">        if (expectedEdgeNumber2 == -1) {</span>
            
            // choose from all of c2
<span class="fc" id="L751">            idx2 = findClosestC2MatchOrderedSearch(sigma2, t2, </span>
                nc.getMatchedContours2());
            
        } else {
            
            // choose from contours of expectedEdgeNumber2
<span class="fc" id="L757">            List&lt;Integer&gt; indexes = curveIndexToC2.get(</span>
                Integer.valueOf(expectedEdgeNumber2));
            
<span class="fc" id="L760">            idx2 = findClosestC2MatchOrderedSearch(sigma2, t2, </span>
                indexes, nc.getMatchedContours2());
        }
        
<span class="fc bfc" id="L764" title="All 2 branches covered.">        if (idx2 == -1) {</span>
<span class="fc" id="L765">            return null;</span>
        }

<span class="fc" id="L768">        return c2.get(idx2);</span>
            
    }

    private int findClosestC2MatchOrderedSearch(double sigma, 
        double scaleFreeLength, List&lt;CurvatureScaleSpaceContour&gt; exclude) {
        
        //TODO: use 0.1*sigma? current sigma factor peak center error
<span class="fc" id="L776">        double tolSigma = 0.04*sigma;</span>
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">        if (tolSigma &lt; 1E-2) {</span>
<span class="nc" id="L778">            tolSigma = 0.1;</span>
        }
        
        // consider wrap around searches too, for scaleFreeLength &gt; 0.5 or 
        // scaleFreeLength &lt; 0.5
<span class="fc bfc" id="L783" title="All 2 branches covered.">        double wrapScaleFreeLength = (scaleFreeLength &gt; 0.5) ?</span>
            scaleFreeLength - 1 : 1 + scaleFreeLength;
        
<span class="fc" id="L786">        double minDiffS = Double.MAX_VALUE;</span>
<span class="fc" id="L787">        double minDiffT = Double.MAX_VALUE;</span>
<span class="fc" id="L788">        int idx = -1;</span>
        
<span class="fc" id="L790">        double minDiff2T = Double.MAX_VALUE;</span>
<span class="fc" id="L791">        int minDiff2TIdx = -1;</span>
        
<span class="fc" id="L793">        double minDiffLen = Double.MAX_VALUE;</span>
<span class="fc" id="L794">        int minDiffLenIdx = -1;</span>
        
<span class="fc bfc" id="L796" title="All 2 branches covered.">        for (int i = 0; i &lt; c2.size(); i++) {</span>
        
<span class="fc" id="L798">            CurvatureScaleSpaceContour c = c2.get(i);</span>
            
<span class="fc bfc" id="L800" title="All 2 branches covered.">            if (exclude.contains(c)) {</span>
<span class="fc" id="L801">                continue;</span>
            }
             
<span class="fc" id="L804">            double diffS = Math.abs(c.getPeakSigma() - sigma);</span>
<span class="fc" id="L805">            double diffT = Math.abs(c.getPeakScaleFreeLength() - </span>
                scaleFreeLength);
            
<span class="fc" id="L808">            double len = Math.sqrt(diffS * diffS + diffT * diffT);</span>
<span class="fc bfc" id="L809" title="All 2 branches covered.">            if (len &lt; minDiffLen) {</span>
<span class="fc" id="L810">                minDiffLen = len;</span>
<span class="fc" id="L811">                minDiffLenIdx = i;</span>
            }
            
<span class="fc bfc" id="L814" title="All 4 branches covered.">            if ((diffS &lt;= (minDiffS + tolSigma)) &amp;&amp; (diffT &lt;= minDiffT)) {</span>
<span class="fc" id="L815">                minDiffS = diffS;</span>
<span class="fc" id="L816">                minDiffT = diffT;</span>
<span class="fc" id="L817">                idx = i;                </span>
<span class="fc bfc" id="L818" title="All 4 branches covered.">            } else if ((diffT &lt; minDiff2T) &amp;&amp; (diffS &lt;= (minDiffS + 3*tolSigma))</span>
                ) {
<span class="fc" id="L820">                minDiff2T = diffT;</span>
<span class="fc" id="L821">                minDiff2TIdx = i;</span>
            }
            
<span class="fc" id="L824">            diffT = Math.abs(c.getPeakScaleFreeLength() - </span>
                wrapScaleFreeLength);
            
<span class="fc" id="L827">            len = Math.sqrt(diffS * diffS + diffT * diffT);</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">            if (len &lt; minDiffLen) {</span>
<span class="fc" id="L829">                minDiffLen = len;</span>
<span class="fc" id="L830">                minDiffLenIdx = i;</span>
            }
            
<span class="fc bfc" id="L833" title="All 4 branches covered.">            if ((diffS &lt;= (minDiffS + tolSigma)) &amp;&amp; (diffT &lt;= minDiffT)) {</span>
<span class="fc" id="L834">                minDiffS = diffS;</span>
<span class="fc" id="L835">                minDiffT = diffT;</span>
<span class="fc" id="L836">                idx = i;                </span>
<span class="fc bfc" id="L837" title="All 4 branches covered.">            } else if ((diffT &lt; minDiff2T) &amp;&amp; (diffS &lt;= (minDiffS + 3*tolSigma))</span>
                ) {
<span class="fc" id="L839">                minDiff2T = diffT;</span>
<span class="fc" id="L840">                minDiff2TIdx = i;</span>
            }
        }
        
<span class="fc bfc" id="L844" title="All 2 branches covered.">        if (minDiffS &gt; 0.2*sigma) {</span>
<span class="fc" id="L845">            return minDiffLenIdx;</span>
        }
        
<span class="fc bfc" id="L848" title="All 2 branches covered.">        if (minDiffT &lt;= minDiff2T) {</span>
<span class="fc" id="L849">            return idx;</span>
        }
        
<span class="fc" id="L852">        return minDiff2TIdx;</span>
    }
    
    private int findClosestC2MatchOrderedSearch(double sigma, 
        double scaleFreeLength, List&lt;Integer&gt; c2Indexes,
        List&lt;CurvatureScaleSpaceContour&gt; exclude) {
        
        //TODO: use a percentage of sigma
<span class="fc" id="L860">        double tolSigma = 0.04*sigma;</span>
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">        if (tolSigma &lt; 1E-2) {</span>
<span class="nc" id="L862">            tolSigma = 0.1;</span>
        }
        
        // consider wrap around searches too, for scaleFreeLength &gt; 0.5 or 
        // scaleFreeLength &lt; 0.5
<span class="fc bfc" id="L867" title="All 2 branches covered.">        double wrapScaleFreeLength = (scaleFreeLength &gt; 0.5) ?</span>
            scaleFreeLength - 1 : 1 + scaleFreeLength;
        
<span class="fc" id="L870">        double minDiffS = Double.MAX_VALUE;</span>
<span class="fc" id="L871">        double minDiffT = Double.MAX_VALUE;</span>
<span class="fc" id="L872">        int idx = -1;</span>
        
<span class="fc" id="L874">        double minDiff2T = Double.MAX_VALUE;</span>
<span class="fc" id="L875">        int minDiff2TIdx = -1;</span>
        
<span class="fc" id="L877">        double minDiffLen = Double.MAX_VALUE;</span>
<span class="fc" id="L878">        int minDiffLenIdx = -1;</span>
        
<span class="fc bfc" id="L880" title="All 2 branches covered.">        for (Integer i : c2Indexes) {</span>
        
<span class="fc" id="L882">            CurvatureScaleSpaceContour c = c2.get(i.intValue());</span>
            
<span class="fc bfc" id="L884" title="All 2 branches covered.">            if (exclude.contains(c)) {</span>
<span class="fc" id="L885">                continue;</span>
            }
            
<span class="fc" id="L888">            double diffS = Math.abs(c.getPeakSigma() - sigma);</span>
<span class="fc" id="L889">            double diffT = Math.abs(c.getPeakScaleFreeLength() - </span>
                scaleFreeLength);
            
<span class="fc" id="L892">            double len = Math.sqrt(diffS * diffS + diffT * diffT);</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">            if (len &lt; minDiffLen) {</span>
<span class="fc" id="L894">                minDiffLen = len;</span>
<span class="fc" id="L895">                minDiffLenIdx = i;</span>
            }
            
<span class="fc bfc" id="L898" title="All 4 branches covered.">            if ((diffS &lt;= (minDiffS + tolSigma)) &amp;&amp; (diffT &lt;= minDiffT)) {</span>
<span class="fc" id="L899">                minDiffS = diffS;</span>
<span class="fc" id="L900">                minDiffT = diffT;</span>
<span class="fc" id="L901">                idx = i.intValue();                </span>
<span class="fc bfc" id="L902" title="All 4 branches covered.">            } else if ((diffT &lt; minDiff2T) &amp;&amp; (diffS &lt;= (minDiffS + 3*tolSigma))</span>
                ) {
<span class="fc" id="L904">                minDiff2T = diffT;</span>
<span class="fc" id="L905">                minDiff2TIdx = i.intValue();</span>
            }
            
<span class="fc" id="L908">            diffT = Math.abs(c.getPeakScaleFreeLength() - </span>
                wrapScaleFreeLength);
            
<span class="fc" id="L911">            len = Math.sqrt(diffS * diffS + diffT * diffT);</span>
<span class="fc bfc" id="L912" title="All 2 branches covered.">            if (len &lt; minDiffLen) {</span>
<span class="fc" id="L913">                minDiffLen = len;</span>
<span class="fc" id="L914">                minDiffLenIdx = i;</span>
            }
            
<span class="fc bfc" id="L917" title="All 4 branches covered.">            if ((diffS &lt;= (minDiffS + tolSigma)) &amp;&amp; (diffT &lt;= minDiffT)) {</span>
<span class="fc" id="L918">                minDiffS = diffS;</span>
<span class="fc" id="L919">                minDiffT = diffT;</span>
<span class="fc" id="L920">                idx = i.intValue();                </span>
<span class="fc bfc" id="L921" title="All 4 branches covered.">            } else if ((diffT &lt; minDiff2T) &amp;&amp; (diffS &lt;= (minDiffS + 3*tolSigma))</span>
                ) {
<span class="fc" id="L923">                minDiff2T = diffT;</span>
<span class="fc" id="L924">                minDiff2TIdx = i.intValue();</span>
            }
<span class="fc" id="L926">        }</span>
        
<span class="fc bfc" id="L928" title="All 2 branches covered.">        if (minDiffS &gt; 0.2*sigma) {</span>
<span class="fc" id="L929">            return minDiffLenIdx;</span>
        }
        
<span class="fc bfc" id="L932" title="All 2 branches covered.">        if (minDiffT &lt;= minDiff2T) {</span>
<span class="fc" id="L933">            return idx;</span>
        }
        
<span class="fc" id="L936">        return minDiff2TIdx;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.3.201306030806</span></div></body></html>
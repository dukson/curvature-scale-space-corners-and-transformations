<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CurvatureScaleSpaceInflectionMapper.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">CurvatureScaleSpaceInflectionMapper.java</span></div><h1>CurvatureScaleSpaceInflectionMapper.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

/**
 * class to map contours from one image to another and return the
 * matched inflection points and a transformation matrix that can
 * be applied to the first to put it into the frame of the second.
 * 
 * The algorithm used for matching scale space image contours is documented in 
 * CurvatureScaleSpaceContourMatcher
 * @see algorithms.imageProcessing.CurvatureScaleSpaceContourMatcher
 * 
 * @author nichole
 */
<span class="pc bpc" id="L20" title="1 of 2 branches missed.">public final class CurvatureScaleSpaceInflectionMapper {</span>
    
<span class="fc" id="L22">    private final Logger log = Logger.getLogger(this.getClass().getName());</span>
    
<span class="fc" id="L24">    private boolean debug = false;</span>
    
<span class="fc" id="L26">    private boolean useLineDrawingMode = false;</span>
        
<span class="fc" id="L28">    private boolean doNotRefineTransformations = false;</span>
    
<span class="fc" id="L30">    private boolean initialized = false;</span>
    
    private final GreyscaleImage image1; 
    private final GreyscaleImage image2;
    
<span class="fc" id="L35">    private List&lt;PairIntArray&gt; edges1 = null;</span>
<span class="fc" id="L36">    private List&lt;PairIntArray&gt; edges2 = null;</span>
    
<span class="fc" id="L38">    private List&lt;CurvatureScaleSpaceContour&gt; contours1 = new </span>
        ArrayList&lt;CurvatureScaleSpaceContour&gt;();
    
<span class="fc" id="L41">    private List&lt;CurvatureScaleSpaceContour&gt; contours2 = new </span>
        ArrayList&lt;CurvatureScaleSpaceContour&gt;();
        
<span class="fc" id="L44">    private List&lt;CurvatureScaleSpaceContour&gt; matchedContours1 = new </span>
        ArrayList&lt;CurvatureScaleSpaceContour&gt;();
    
<span class="fc" id="L47">    private List&lt;CurvatureScaleSpaceContour&gt; matchedContours2 = new </span>
        ArrayList&lt;CurvatureScaleSpaceContour&gt;();
    
<span class="fc" id="L50">    private PairIntArray matchedXY1 = null;</span>
    
<span class="fc" id="L52">    private PairIntArray matchedXY2 = null;</span>
    
<span class="fc" id="L54">    private int offsetImageX1 = 0;</span>
    
<span class="fc" id="L56">    private int offsetImageY1 = 0;</span>
    
<span class="fc" id="L58">    private int offsetImageX2 = 0;</span>
    
<span class="fc" id="L60">    private int offsetImageY2 = 0;</span>
        
    public void useLineDrawingLineMode() {
<span class="fc" id="L63">        this.useLineDrawingMode = true;</span>
<span class="fc" id="L64">    }</span>
    
    public void doNotRefineTransformations() {
<span class="nc" id="L67">        doNotRefineTransformations = true;</span>
<span class="nc" id="L68">    }</span>
    
    public void useDebugMode() {
<span class="nc" id="L71">        debug = true;</span>
<span class="nc" id="L72">    }</span>
    
    public void initialize() {
        
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">        if (initialized) {</span>
<span class="nc" id="L77">            return;</span>
        }
        
        // note that if the orientation of image2 with respect to image1 is
        // more than 180 degrees, the code in the edge extractor will be forming
        // the edges by reading in the reverse direction in x and y,
        // so the edges will have opposite orientation.
        // The code also reverses edges to append curves read in other directions,
        // so in general, one cannot assure that the points are ordered in
        // a clockwise or counterclockwise manner at this point.
        // the curves tend to be ordered counter clockwise.
        // because the closed curve shapes are not simple convex or concave
        // shapes sometimes, it's not as easy to tell whether points are 
        // ordered clockwise in a curve.
        // Tests so far show that testing the contour peak points 
        // (left and right) for clockwise order gives the right answer 
        // and is less work computationally
        
<span class="fc" id="L95">        CurvatureScaleSpaceImageMaker imgMaker</span>
            = new CurvatureScaleSpaceImageMaker(image1);
        
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">        if (useLineDrawingMode) {</span>
<span class="fc" id="L99">            imgMaker.useLineDrawingMode();</span>
        }
        
<span class="fc" id="L102">        MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
        
<span class="fc" id="L104">        edges1 = imgMaker.getClosedCurves();</span>
        
<span class="fc" id="L106">        boolean didReverse = false;</span>
        
<span class="fc bfc" id="L108" title="All 2 branches covered.">        for (int i = 0; i &lt; edges1.size(); i++) {</span>

<span class="fc" id="L110">            PairIntArray curve = edges1.get(i);</span>

<span class="fc" id="L112">            Map&lt;Float, ScaleSpaceCurve&gt; scaleSpaceMap</span>
                = imgMaker.createScaleSpaceMetricsForEdge2(curve);

<span class="fc" id="L115">            ScaleSpaceCurveImage scaleSpaceImage</span>
                = imgMaker.convertScaleSpaceMapToSparseImage(scaleSpaceMap, i);
                 
<span class="fc" id="L118">            ContourFinder contourFinder = new ContourFinder();</span>

<span class="fc" id="L120">            List&lt;CurvatureScaleSpaceContour&gt; result = contourFinder.findContours(</span>
                scaleSpaceImage, i);
                    
<span class="fc" id="L123">            PairIntArray testContour = new PairIntArray();</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">            for (int j = 0; j &lt; result.size(); j++) {</span>
<span class="fc" id="L125">                CurvatureScaleSpaceContour c = result.get(j);</span>
<span class="fc" id="L126">                CurvatureScaleSpaceImagePoint[] points = c.getPeakDetails();</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">                for (int jj = 0; jj &lt; points.length; jj++) {</span>
<span class="fc" id="L128">                    testContour.add((int)points[jj].getXCoord(), </span>
                        (int)points[jj].getYCoord());
                }
            }
            
<span class="fc" id="L133">            boolean isCW = curveHelper.curveIsOrderedClockwise(testContour);</span>
<span class="fc" id="L134">            log.fine(&quot;EDGES1: contour isCW=&quot; + isCW);</span>
            
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">            if (isCW) {</span>
                
<span class="nc" id="L138">                didReverse = true;</span>
                
<span class="nc bnc" id="L140" title="All 2 branches missed.">                for (int j = 0; j &lt; result.size(); j++) {</span>
                    
<span class="nc" id="L142">                    CurvatureScaleSpaceContour contour = result.get(j);</span>
                                        
<span class="nc" id="L144">                    CurvatureScaleSpaceContour reversed = </span>
                        new CurvatureScaleSpaceContour(contour.getPeakSigma(), 
                        1.0f - contour.getPeakScaleFreeLength());
                    
<span class="nc" id="L148">                    CurvatureScaleSpaceImagePoint[] points = </span>
                        contour.getPeakDetails();
<span class="nc bnc" id="L150" title="All 2 branches missed.">                    if (points.length &gt; 1) {</span>
<span class="nc" id="L151">                        CurvatureScaleSpaceImagePoint tmp = points[0];</span>
<span class="nc" id="L152">                        points[0] = points[1];</span>
<span class="nc" id="L153">                        points[1] = tmp;</span>
                    }
<span class="nc bnc" id="L155" title="All 2 branches missed.">                    for (int jj = 0; jj &lt; points.length; jj++) {</span>
<span class="nc" id="L156">                        points[jj].setScaleFreeLength(1.0f - </span>
                            points[jj].getScaleFreeLength());
                    }
<span class="nc" id="L159">                    reversed.setPeakDetails(points);</span>
<span class="nc" id="L160">                    reversed.setEdgeNumber(contour.getEdgeNumber());</span>
                                        
<span class="nc" id="L162">                    result.set(j, reversed);</span>
                }
            }
            
<span class="fc" id="L166">            contours1.addAll(result);</span>
        }
        
<span class="pc bpc" id="L169" title="2 of 4 branches missed.">        if ((edges1.size() &gt; 1) || didReverse) {</span>
<span class="nc" id="L170">            Collections.sort(contours1, new DescendingSigmaComparator());</span>
        }
        
        /*
        note that when modifying the contour lists in any way, one has to
        maintain decreasing order by sigma and when sigma is equal, the
        order must be by increasing scale free parameter.
        two of the search methods in the matcher depend upon those properties.
        */
        
<span class="fc" id="L180">        offsetImageX1 = imgMaker.getTrimmedXOffset();</span>
        
<span class="fc" id="L182">        offsetImageY1 = imgMaker.getTrimmedYOffset();</span>
        
<span class="fc" id="L184">        imgMaker</span>
            = new CurvatureScaleSpaceImageMaker(image2);
        
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        if (useLineDrawingMode) {</span>
<span class="fc" id="L188">            imgMaker.useLineDrawingMode();</span>
        }
        
<span class="fc" id="L191">        edges2 = imgMaker.getClosedCurves();</span>
        
<span class="fc" id="L193">        didReverse = false;</span>
        
<span class="fc bfc" id="L195" title="All 2 branches covered.">        for (int i = 0; i &lt; edges2.size(); i++) {</span>

<span class="fc" id="L197">            PairIntArray curve = edges2.get(i);</span>
            
<span class="fc" id="L199">            Map&lt;Float, ScaleSpaceCurve&gt; scaleSpaceMap</span>
                = imgMaker.createScaleSpaceMetricsForEdge2(curve);

<span class="fc" id="L202">            ScaleSpaceCurveImage scaleSpaceImage</span>
                = imgMaker.convertScaleSpaceMapToSparseImage(scaleSpaceMap, i);
                 
<span class="fc" id="L205">            ContourFinder contourFinder = new ContourFinder();</span>

<span class="fc" id="L207">            List&lt;CurvatureScaleSpaceContour&gt; result = contourFinder.findContours(</span>
                scaleSpaceImage, i);
            
<span class="fc" id="L210">            PairIntArray testContour = new PairIntArray();</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">            for (int j = 0; j &lt; result.size(); j++) {</span>
<span class="fc" id="L212">                CurvatureScaleSpaceContour c = result.get(j);</span>
<span class="fc" id="L213">                CurvatureScaleSpaceImagePoint[] points = c.getPeakDetails();</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">                for (int jj = 0; jj &lt; points.length; jj++) {</span>
<span class="fc" id="L215">                    testContour.add((int)points[jj].getXCoord(), </span>
                        (int)points[jj].getYCoord());
                }
            }
            
<span class="fc" id="L220">            boolean isCW = curveHelper.curveIsOrderedClockwise(testContour);</span>
<span class="fc" id="L221">            log.fine(&quot;EDGES2: contour isCW=&quot; + isCW);</span>
            
<span class="fc bfc" id="L223" title="All 2 branches covered.">            if (isCW) {</span>
                
<span class="fc" id="L225">                didReverse = true;</span>
                
<span class="fc bfc" id="L227" title="All 2 branches covered.">                for (int j = 0; j &lt; result.size(); j++) {</span>
                    
<span class="fc" id="L229">                    CurvatureScaleSpaceContour contour = result.get(j);</span>
                                        
<span class="fc" id="L231">                    CurvatureScaleSpaceContour reversed = </span>
                        new CurvatureScaleSpaceContour(contour.getPeakSigma(), 
                        1.0f - contour.getPeakScaleFreeLength());
                    
<span class="fc" id="L235">                    CurvatureScaleSpaceImagePoint[] points = </span>
                        contour.getPeakDetails();
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">                    if (points.length &gt; 1) {</span>
<span class="fc" id="L238">                        CurvatureScaleSpaceImagePoint tmp = points[0];</span>
<span class="fc" id="L239">                        points[0] = points[1];</span>
<span class="fc" id="L240">                        points[1] = tmp;</span>
                    }
<span class="fc bfc" id="L242" title="All 2 branches covered.">                    for (int jj = 0; jj &lt; points.length; jj++) {</span>
<span class="fc" id="L243">                        points[jj].setScaleFreeLength(1.0f - </span>
                            points[jj].getScaleFreeLength());
                    }
<span class="fc" id="L246">                    reversed.setPeakDetails(points);</span>
<span class="fc" id="L247">                    reversed.setEdgeNumber(contour.getEdgeNumber());</span>
                                        
<span class="fc" id="L249">                    result.set(j, reversed);</span>
                }
            }
            
<span class="fc" id="L253">            contours2.addAll(result);</span>
        }
        
<span class="fc bfc" id="L256" title="All 4 branches covered.">        if ((edges2.size() &gt; 1) || didReverse) {</span>
<span class="fc" id="L257">            Collections.sort(contours2, new DescendingSigmaComparator());            </span>
        }
        
<span class="fc" id="L260">        offsetImageX2 = imgMaker.getTrimmedXOffset();</span>
        
<span class="fc" id="L262">        offsetImageY2 = imgMaker.getTrimmedYOffset();</span>
        
<span class="fc" id="L264">        initialized = true;</span>
<span class="fc" id="L265">    }</span>
    
    public CurvatureScaleSpaceInflectionMapper(GreyscaleImage image1, 
<span class="fc" id="L268">        GreyscaleImage image2) {</span>
        
<span class="fc" id="L270">        this.image1 = image1;</span>
        
<span class="fc" id="L272">        this.image2 = image2;</span>
<span class="fc" id="L273">    }</span>
  
    /**
     * coordinate transformations from image 1 to image 2 are calculated from
     * matching scale space image contours.
     *
     * positive Y is down 
       positive X is right
       positive theta starts from Y=0, X&gt;=0 and proceeds CW
                270
                 |     
                 |
          180--------- 0   +X
                 |   
                 |   
                 90
                 +Y
     * &lt;/pre&gt;
     * NOTE: this will return null if it did not find closed 
     * curves in each image for which to map between.
     * 
     * @return 
     */
    public TransformationParameters createEuclideanTransformation() {
        
<span class="fc" id="L298">        initialize();</span>
        
<span class="pc bpc" id="L300" title="2 of 4 branches missed.">        if (contours2.isEmpty() || contours1.isEmpty()) {</span>
<span class="nc" id="L301">            return null;</span>
        }
        
<span class="fc" id="L304">        CurvatureScaleSpaceContourMatcher matcher = </span>
            new CurvatureScaleSpaceContourMatcher(contours1, contours2);
        
<span class="fc" id="L307">        matcher.matchContours();</span>
        
<span class="fc" id="L309">        List&lt;CurvatureScaleSpaceContour&gt; transAppliedTo1 = </span>
            matcher.getSolutionMatchedContours1();
        
<span class="fc" id="L312">        List&lt;CurvatureScaleSpaceContour&gt; transAppliedTo2 = </span>
            matcher.getSolutionMatchedContours2();
        
<span class="pc bpc" id="L315" title="3 of 4 branches missed.">        assert(transAppliedTo1.size() == transAppliedTo2.size());</span>
        
<span class="fc" id="L317">        matchedContours1.addAll(transAppliedTo1);</span>
        
<span class="fc" id="L319">        matchedContours2.addAll(transAppliedTo2);</span>
                
        // ==== adding back the image offsets removed when trimming image
        
        // ======= make a weighted sum of points to get the centroid of the edge
        // ============= the weight is sigma of total sum of sigmas
        
<span class="fc" id="L326">        PairIntArray xy1 = new PairIntArray(transAppliedTo1.size());</span>
<span class="fc" id="L327">        PairIntArray xy2 = new PairIntArray(transAppliedTo1.size());</span>
<span class="fc" id="L328">        List&lt;Float&gt; weights1 = new ArrayList&lt;Float&gt;();</span>
<span class="fc" id="L329">        List&lt;Float&gt; weights2 = new ArrayList&lt;Float&gt;();</span>
     
<span class="fc" id="L331">        double sumS1 = 0;</span>
<span class="fc" id="L332">        double sumS2 = 0;</span>
                    
<span class="fc bfc" id="L334" title="All 2 branches covered.">        for (int i = 0; i &lt; transAppliedTo1.size(); i++) {</span>
                        
<span class="fc" id="L336">            CurvatureScaleSpaceContour c1 = transAppliedTo1.get(i);</span>
            
<span class="fc" id="L338">            CurvatureScaleSpaceContour c2 = transAppliedTo2.get(i);</span>
            
<span class="fc" id="L340">            float sigma1 = c1.getPeakSigma();</span>
<span class="fc" id="L341">            float sigma2 = c2.getPeakSigma();</span>

<span class="fc" id="L343">            StringBuilder s1 = new StringBuilder();</span>
<span class="fc" id="L344">            StringBuilder s2 = new StringBuilder();</span>

<span class="pc bpc" id="L346" title="1 of 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L347">                s1.append(String.format(&quot;CONTOUR PEAK1: (%f, %f)&quot;, </span>
                    c1.getPeakSigma(), c1.getPeakScaleFreeLength()));
<span class="nc" id="L349">                s2.append(String.format(&quot;CONTOUR PEAK2: (%f, %f)&quot;, </span>
                    c2.getPeakSigma(), c2.getPeakScaleFreeLength()));
            }
            
            // the contours extracted from scale space images using a factor of
            // 2^(1/8) for recursive convolution tend to not have a single
            // peak, so the correction here for the single peak case is not 
            // usually needed.  for that rare case, just doubling the peak
            // for comparison to the matched contour
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">            if (c1.getPeakDetails().length != c2.getPeakDetails().length) {</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">                if (c1.getPeakDetails().length == 1) {</span>
<span class="nc" id="L360">                    CurvatureScaleSpaceImagePoint[] p = new</span>
                        CurvatureScaleSpaceImagePoint[]{
                        c1.getPeakDetails()[0], c1.getPeakDetails()[0]};
<span class="nc" id="L363">                    c1.setPeakDetails(p);</span>
<span class="nc" id="L364">                    transAppliedTo1.set(i, c1);</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                } else if (c2.getPeakDetails().length == 1) {</span>
<span class="nc" id="L366">                    CurvatureScaleSpaceImagePoint[] p = new</span>
                        CurvatureScaleSpaceImagePoint[]{
                        c2.getPeakDetails()[0], c2.getPeakDetails()[0]};                
<span class="nc" id="L369">                    c2.setPeakDetails(p);</span>
<span class="nc" id="L370">                    transAppliedTo2.set(i, c2);</span>
                }
            }
                                
<span class="fc bfc" id="L374" title="All 2 branches covered.">            for (int j = 0; j &lt; c1.getPeakDetails().length; j++) {</span>

<span class="fc" id="L376">                CurvatureScaleSpaceImagePoint spaceImagePoint = </span>
                    c1.getPeakDetails()[j];

<span class="fc" id="L379">                int x = spaceImagePoint.getXCoord() + offsetImageX1;</span>
<span class="fc" id="L380">                int y = spaceImagePoint.getYCoord() + offsetImageY1;</span>
<span class="fc" id="L381">                xy1.add(x, y);</span>
<span class="fc" id="L382">                weights1.add(Float.valueOf(sigma1));</span>
<span class="fc" id="L383">                sumS1 += sigma1;</span>
                   
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">                if (debug) {</span>
<span class="nc" id="L386">                    s1.append(String.format(&quot; (%d, %d)&quot;, x, y));</span>
                }

<span class="fc" id="L389">                spaceImagePoint = c2.getPeakDetails()[j];</span>

<span class="fc" id="L391">                x = spaceImagePoint.getXCoord() + offsetImageX2;</span>
<span class="fc" id="L392">                y = spaceImagePoint.getYCoord() + offsetImageY2;</span>
<span class="fc" id="L393">                xy2.add(x, y);</span>
<span class="fc" id="L394">                weights2.add(Float.valueOf(sigma2));</span>
<span class="fc" id="L395">                sumS2 += sigma2;</span>
                    
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">                if (debug) {</span>
<span class="nc" id="L398">                    s2.append(String.format(&quot; (%d, %d)&quot;, x, y));</span>
                }
            }
            
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L403">                log.info(s1.toString());</span>
<span class="nc" id="L404">                log.info(s2.toString());</span>
            }
        }

<span class="pc bpc" id="L408" title="1 of 2 branches missed.">        if (xy1.getN() &lt; 3) {</span>
<span class="nc" id="L409">            throw new IllegalStateException(&quot;need at least 3 points&quot;);</span>
        }
        
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L413">            log.info(&quot;offsetImgX1=&quot; + offsetImageX1 </span>
                + &quot; offsetImgY1=&quot; + offsetImageY1
                + &quot;\noffsetImgX2=&quot; + offsetImageX2 
                + &quot; offsetImgY2=&quot; + offsetImageY2
            );
        }
            
<span class="fc" id="L420">        matchedXY1 = xy1;</span>
<span class="fc" id="L421">        matchedXY2 = xy2;</span>
                
<span class="fc" id="L423">        float[] w1 = new float[weights1.size()];</span>
<span class="fc" id="L424">        float[] w2 = new float[weights2.size()];</span>
        
<span class="fc bfc" id="L426" title="All 2 branches covered.">        for (int i = 0; i &lt; weights1.size(); i++) {</span>
<span class="fc" id="L427">            double tmp = weights1.get(i).floatValue()/sumS1;</span>
<span class="fc" id="L428">            w1[i] = Float.valueOf((float)tmp);</span>
        }
<span class="fc bfc" id="L430" title="All 2 branches covered.">        for (int i = 0; i &lt; weights2.size(); i++) {</span>
<span class="fc" id="L431">            double tmp = weights2.get(i).floatValue()/sumS2;</span>
<span class="fc" id="L432">            w2[i] = Float.valueOf((float)tmp);</span>
        }
        
<span class="fc" id="L435">        TransformationCalculator tc = new TransformationCalculator();</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L437">            tc.useDebugMode();</span>
        }
        
<span class="fc" id="L440">        TransformationParameters params =</span>
            tc.calulateEuclidean(matchedXY1, w1,
                matchedXY2, w2);
       
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">        if (!doNotRefineTransformations) {</span>
            
<span class="fc" id="L446">            params = refineEuclideanSolution(params);</span>
            
<span class="fc" id="L448">            double mc =  (float) Math.cos(params.getRotationInRadians());</span>
<span class="fc" id="L449">            double ms =  (float) Math.sin(params.getRotationInRadians());</span>
<span class="fc" id="L450">            double scale = params.getScale();</span>
            
<span class="fc" id="L452">            MiscellaneousCurveHelper curveHelper = new MiscellaneousCurveHelper();</span>
        
<span class="fc" id="L454">            double[] centroidsX1 = curveHelper.calculateXYCentroids(matchedXY1);</span>
<span class="fc" id="L455">            double centroidX1 = centroidsX1[0];</span>
<span class="fc" id="L456">            double centroidY1 = centroidsX1[1];</span>
<span class="fc" id="L457">            double[] centroidsX2 = curveHelper.calculateXYCentroids(matchedXY2);</span>
<span class="fc" id="L458">            double centroidX2 = centroidsX2[0];</span>
<span class="fc" id="L459">            double centroidY2 = centroidsX2[1];</span>
            
<span class="fc" id="L461">            float translationX = (float)(centroidX2 - (centroidX1*scale*mc) </span>
                - (centroidY1*scale*ms));
<span class="fc" id="L463">            float translationY = (float)(centroidY2 + (centroidX1*scale*ms) </span>
                - (centroidY1*scale*mc));
            
<span class="fc" id="L466">            params.setTranslationX(translationX);</span>
<span class="fc" id="L467">            params.setTranslationY(translationY);</span>
            
<span class="fc" id="L469">            log.info(&quot;FINAL:\n&quot; + params.toString());</span>
        }
        
<span class="fc" id="L472">        return params;</span>
    }
    
    public PairIntArray getMatchedXY1() {
<span class="nc" id="L476">        return matchedXY1;</span>
    }
    
    public PairIntArray getMatchedXY2() {
<span class="nc" id="L480">        return matchedXY2;</span>
    }

    public List&lt;CurvatureScaleSpaceContour&gt; getMatchedContours1() {
<span class="nc" id="L484">        return matchedContours1;</span>
    }
    
    public List&lt;CurvatureScaleSpaceContour&gt; getMatchedContours2() {
<span class="nc" id="L488">        return matchedContours2;</span>
    }
    
    protected GreyscaleImage getImage1() {
<span class="nc" id="L492">        return image1;</span>
    }
    protected GreyscaleImage getImage2() {
<span class="nc" id="L495">        return image2;</span>
    }
    protected List&lt;PairIntArray&gt; getEdges1() {
<span class="fc" id="L498">        return edges1;</span>
    }
    protected List&lt;PairIntArray&gt; getEdges2() {
<span class="fc" id="L501">        return edges2;</span>
    }
    
    protected List&lt;PairIntArray&gt; getEdges1InOriginalReferenceFrame() {
<span class="fc" id="L505">        List&lt;PairIntArray&gt; oe = new ArrayList&lt;PairIntArray&gt;();</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">        for (int i = 0; i &lt; edges1.size(); i++) {</span>
<span class="fc" id="L507">            PairIntArray edge = edges1.get(i);</span>
<span class="fc" id="L508">            PairIntArray e = new PairIntArray();</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">            for (int j = 0; j &lt; edge.getN(); j++) {</span>
<span class="fc" id="L510">                e.add(edge.getX(j) + offsetImageX1, edge.getY(j) + offsetImageY1);</span>
            }
<span class="fc" id="L512">            oe.add(e);</span>
        } 
<span class="fc" id="L514">        return oe;</span>
    }
    protected List&lt;PairIntArray&gt; getEdges2InOriginalReferenceFrame() {
<span class="nc" id="L517">        List&lt;PairIntArray&gt; oe = new ArrayList&lt;PairIntArray&gt;();</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">        for (int i = 0; i &lt; edges2.size(); i++) {</span>
<span class="nc" id="L519">            PairIntArray edge = edges2.get(i);</span>
<span class="nc" id="L520">            PairIntArray e = new PairIntArray();</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">            for (int j = 0; j &lt; edge.getN(); j++) {</span>
<span class="nc" id="L522">                e.add(edge.getX(j) + offsetImageX2, edge.getY(j) + offsetImageY2);</span>
            }
<span class="nc" id="L524">            oe.add(e);</span>
        } 
<span class="nc" id="L526">        return oe;</span>
    }
    
    public PairInt[] getMatchedEdgesIndexes() {
         
<span class="fc" id="L531">        List&lt;Integer&gt; idx1 = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L532">        List&lt;Integer&gt; idx2 = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">        for (int i = 0; i &lt; this.matchedContours1.size(); i++) {</span>
<span class="fc" id="L534">            Integer edge1Idx = Integer.valueOf(</span>
                matchedContours1.get(i).getEdgeNumber());
<span class="fc" id="L536">            Integer edge2Idx = Integer.valueOf(</span>
                matchedContours2.get(i).getEdgeNumber());
            
<span class="fc bfc" id="L539" title="All 2 branches covered.">            if (!idx1.contains(edge1Idx)) {</span>
<span class="fc" id="L540">                idx1.add(edge1Idx);</span>
<span class="fc" id="L541">                idx2.add(edge2Idx);</span>
            }
        }
        
<span class="fc" id="L545">        PairInt[] indexes = new PairInt[idx1.size()];</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">        for (int i = 0; i &lt; idx1.size(); i++) {</span>
<span class="fc" id="L547">            indexes[i] = new PairInt(idx1.get(i), idx2.get(i));</span>
        }
        
<span class="fc" id="L550">        return indexes;</span>
    }

    private TransformationParameters refineEuclideanSolution(
        TransformationParameters params) {
        
        // transform edges in matchedContours1 to matchedContours2
        // and reduce the difference within max num of iterations and 
        // tolerance
       
<span class="fc" id="L560">        PairInt[] matchedEdgesIndexes = getMatchedEdgesIndexes();</span>
        
<span class="fc" id="L562">        PairIntArray[] matchedEdges1 = new PairIntArray[matchedEdgesIndexes.length];</span>
<span class="fc" id="L563">        PairIntArray[] matchedEdges2 = new PairIntArray[matchedEdges1.length];</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">        for (int i = 0; i &lt; matchedEdgesIndexes.length; i++) {</span>
<span class="fc" id="L565">            int edge1Idx = matchedEdgesIndexes[i].getX();</span>
<span class="fc" id="L566">            int edge2Idx = matchedEdgesIndexes[i].getY();</span>
<span class="fc" id="L567">            matchedEdges1[i] = edges1.get(edge1Idx);</span>
<span class="fc" id="L568">            matchedEdges2[i] = edges2.get(edge2Idx);</span>
        }
        
        //TODO: consider impl a non-linear conjugate gradient search to replace
        // this:
<span class="fc" id="L573">        TransformationRefiner chSqMin = new TransformationRefiner();</span>
        
<span class="fc" id="L575">        TransformationParameters out = chSqMin.refineTransformation(matchedEdges1, </span>
            matchedEdges2, params);
        
<span class="fc" id="L578">        return out;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.3.201306030806</span></div></body></html>
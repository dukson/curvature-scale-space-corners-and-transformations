<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EdgeMatcher.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing</a> &gt; <span class="el_source">EdgeMatcher.java</span></div><h1>EdgeMatcher.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing;

import algorithms.util.PairFloatArray;
import algorithms.util.PairIntArray;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Logger;

/**
 * class to match the edges extracted from two images.  The use of corners and
 * PointMatcher should be preferred over this.
 
 * @author nichole
 */
<span class="fc" id="L16">public final class EdgeMatcher extends AbstractPointMatcher {</span>

<span class="fc" id="L18">    private final Logger log = Logger.getLogger(this.getClass().getName());</span>

<span class="fc" id="L20">    protected boolean debug = true;</span>

    // ======= code that needs testing and revision the most
    /**
     * refine the transformation params to make a better match of edges1 to
     * edges2 where the points within edges in both sets are not necessarily
     * 1 to 1 matches (that is, they are lines with uneven point intervals
     * and densities).
     *
     &lt;pre&gt;
     These are the parameters used for the search and they may need to be 
     altered with more test cases:
         float rotationHalfRangeInDegrees = 6;
         float rotationDeltaInDegrees = 2.f;
         float scaleHalfRange = 0.15f; 
         float scaleDelta = 0.025f;
         float translationXHalfRange = 10; 
         float translationXDelta = 4.f;
     &lt;/pre&gt;
     * 
     * @param edges1
     * @param edges2
     * @param params
     * @return
     */
    public TransformationPointFit refineTransformation(PairIntArray[] edges1,
        PairIntArray[] edges2, final TransformationParameters params) {

<span class="pc bpc" id="L48" title="2 of 4 branches missed.">        if (edges1 == null || edges1.length == 0) {</span>
<span class="nc" id="L49">            throw new IllegalArgumentException(&quot;edges1 cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L51" title="2 of 4 branches missed.">        if (edges2 == null || edges2.length == 0) {</span>
<span class="nc" id="L52">            throw new IllegalArgumentException(&quot;edges2 cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">        if (edges1.length != edges2.length) {</span>
<span class="nc" id="L55">            throw new IllegalArgumentException(</span>
                &quot;edges1 and edges2 must be the same length&quot;);
        }

<span class="fc" id="L59">        int n = edges1.length;</span>
        
<span class="fc" id="L61">        log.info(&quot;refining coordinates with &quot; + n  + &quot; curves&quot;);</span>
        
<span class="fc" id="L63">        float rotHalfRangeInDegrees = 6;</span>
<span class="fc" id="L64">        float rotDeltaInDegrees = 2.f;</span>
<span class="fc" id="L65">        float scaleHalfRange = 0.15f; </span>
<span class="fc" id="L66">        float scaleDelta = 0.025f;</span>
<span class="fc" id="L67">        float transXHalfRange = 10; </span>
<span class="fc" id="L68">        float transXDelta = 4.f;</span>
<span class="fc" id="L69">        float transYHalfRange = transXHalfRange; </span>
<span class="fc" id="L70">        float transYDelta = transXDelta;</span>
        
<span class="fc" id="L72">        float tolTransX = 4;</span>
<span class="fc" id="L73">        float tolTransY = 4;</span>
        
<span class="fc" id="L75">        boolean useGreedyMatching = true;</span>
        
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">        if (!useGreedyMatching) {</span>
<span class="nc" id="L78">            tolTransX = 2;</span>
<span class="nc" id="L79">            tolTransY = 2;</span>
        }
        
        // start with original fit to make results are an improvement
<span class="fc" id="L83">        TransformationPointFit bestFit = evaluate(params, edges1, edges2,</span>
            tolTransX, tolTransY, useGreedyMatching);
        
<span class="fc" id="L86">        PointMatcher pointMatcher = new PointMatcher();        </span>
                
<span class="fc" id="L88">        int nMaxMatchableSum = countMaxMatchable(edges1, edges2);</span>
        
<span class="fc" id="L90">        float scaleWeighted = 0;</span>
<span class="fc" id="L91">        float rotationWeighted = 0;</span>
<span class="fc" id="L92">        float transXWeighted = 0;</span>
<span class="fc" id="L93">        float transYWeighted = 0;</span>
        
<span class="fc bfc" id="L95" title="All 2 branches covered.">        for (int i = 0; i &lt; n; ++i) {</span>
            
<span class="fc" id="L97">            PairIntArray set1 = edges1[i];</span>
<span class="fc" id="L98">            PairIntArray set2 = edges2[i];</span>
                        
<span class="fc" id="L100">            TransformationPointFit fit = pointMatcher.refineTheTransformation(</span>
                params, set1, set2, 
                scaleHalfRange, scaleDelta,
                rotHalfRangeInDegrees, rotDeltaInDegrees, 
                transXHalfRange, transXDelta, 
                transYHalfRange, transYDelta,
                useGreedyMatching);
            
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">            if (fit == null) {</span>
<span class="nc" id="L109">                continue;</span>
            }
            
<span class="fc" id="L112">            int nMaxMatchable = Math.min(set1.getN(), set2.getN());</span>
            
<span class="fc" id="L114">            float weight = (float)nMaxMatchable/(float)nMaxMatchableSum;</span>
            
<span class="fc" id="L116">            scaleWeighted += (fit.getScale() * weight);</span>
<span class="fc" id="L117">            rotationWeighted += </span>
<span class="fc" id="L118">                ((fit.getParameters().getRotationInDegrees()/360.f)  * weight);</span>
<span class="fc" id="L119">            transXWeighted += (fit.getTranslationX() * weight);</span>
<span class="fc" id="L120">            transYWeighted += (fit.getTranslationY() * weight);</span>
        }
        
<span class="fc" id="L123">        rotationWeighted *= Math.PI*2;</span>
        
<span class="fc" id="L125">        TransformationParameters paramsWeighted = new TransformationParameters();</span>
<span class="fc" id="L126">        paramsWeighted.setScale(scaleWeighted);</span>
<span class="fc" id="L127">        paramsWeighted.setRotationInRadians(rotationWeighted);</span>
<span class="fc" id="L128">        paramsWeighted.setTranslationX(transXWeighted);</span>
<span class="fc" id="L129">        paramsWeighted.setTranslationY(transYWeighted);</span>
<span class="fc" id="L130">        paramsWeighted.setOriginX(params.getOriginX());</span>
<span class="fc" id="L131">        paramsWeighted.setOriginY(params.getOriginY());</span>
        
<span class="fc" id="L133">        TransformationPointFit weightedFit = evaluate(paramsWeighted, </span>
            edges1, edges2,tolTransX, tolTransY, useGreedyMatching);
        
<span class="fc bfc" id="L136" title="All 2 branches covered.">        if (pointMatcher.fitIsBetter(bestFit, weightedFit)) {</span>
<span class="fc" id="L137">            bestFit = weightedFit;</span>
<span class="fc" id="L138">log.info(&quot;REFINEMENT ACCEPTED&quot;);</span>
        }
        
<span class="fc" id="L141">        return bestFit;</span>
    }

    protected int countMaxMatchable(PairIntArray[] edges1, PairIntArray[] edges2) {
        
<span class="fc" id="L146">        int sum = 0;</span>
        
<span class="fc bfc" id="L148" title="All 2 branches covered.">        for (int i = 0; i &lt; edges1.length; ++i) {</span>
<span class="fc" id="L149">            PairIntArray set1 = edges1[i];</span>
<span class="fc" id="L150">            PairIntArray set2 = edges2[i];</span>
<span class="fc" id="L151">            int nMaxMatchable = Math.min(set1.getN(), set2.getN());</span>
            
<span class="fc" id="L153">            sum += nMaxMatchable;</span>
        }
        
<span class="fc" id="L156">        return sum;</span>
    }

    public TransformationPointFit evaluate(TransformationParameters 
        params, PairIntArray[] edges1, PairIntArray[] edges2,
        float tolTransX, float tolTransY,
        boolean useGreedyMatching) {
        
<span class="pc bpc" id="L164" title="2 of 4 branches missed.">        if (edges1 == null || edges1.length == 0) {</span>
<span class="nc" id="L165">            throw new IllegalArgumentException(&quot;edges1 cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L167" title="2 of 4 branches missed.">        if (edges2 == null || edges2.length == 0) {</span>
<span class="nc" id="L168">            throw new IllegalArgumentException(&quot;edges2 cannot be null or empty&quot;);</span>
        }
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (edges1.length != edges2.length) {</span>
<span class="nc" id="L171">            throw new IllegalArgumentException(</span>
                &quot;edges1 and edges2 must be the same length&quot;);
        }
        
<span class="fc" id="L175">        PointMatcher pointMatcher = new PointMatcher();</span>
        
<span class="fc" id="L177">        Transformer transformer = new Transformer();</span>
        
<span class="fc" id="L179">        int nMaxMatchableSum = countMaxMatchable(edges1, edges2);</span>
        
        /*
        either need a high tolerance with greedy matching or
        a low tolerance and optimal matching.
        The first is N^2 and the 3nd is approx N^4, respectively.
        */
        
<span class="fc" id="L187">        int nMatched = 0;</span>
<span class="fc" id="L188">        float difFromModelWeighted = 0;</span>
<span class="fc" id="L189">        double stDevFromModelWeightedSqSum = 0;</span>
                
<span class="fc bfc" id="L191" title="All 2 branches covered.">        for (int i = 0; i &lt; edges1.length; ++i) {</span>
<span class="fc" id="L192">            PairIntArray set1 = edges1[i];</span>
<span class="fc" id="L193">            PairIntArray set2 = edges2[i];</span>
            
<span class="fc" id="L195">            PairFloatArray tr = transformer.applyTransformation2(</span>
               params, set1);
            
<span class="fc" id="L198">            int nMaxMatchable = Math.min(set1.getN(), set2.getN());</span>
<span class="fc" id="L199">            float weight = (float)nMaxMatchable/(float)nMaxMatchableSum;</span>
         
            TransformationPointFit fit;
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">            if (useGreedyMatching) {</span>
<span class="fc" id="L203">                fit = pointMatcher.evaluateFitForUnMatchedTransformedGreedy(</span>
                params, tr, set2, tolTransX, tolTransY);
            } else {
<span class="nc" id="L206">                fit = pointMatcher.evaluateFitForUnMatchedTransformedOptimal(</span>
                params, tr, set2, tolTransX, tolTransY);
            }
            
<span class="fc" id="L210">            nMatched += fit.getNumberOfMatchedPoints();</span>
<span class="fc" id="L211">            difFromModelWeighted += (fit.getMeanDistFromModel() * weight);</span>
<span class="fc" id="L212">            stDevFromModelWeightedSqSum += </span>
<span class="fc" id="L213">                (fit.getStDevFromMean() * fit.getStDevFromMean() * weight);</span>
        }
        
<span class="fc" id="L216">        float stDevFromModelWeighted = (float)Math.sqrt(stDevFromModelWeightedSqSum);</span>
        
<span class="fc" id="L218">        TransformationPointFit fit = new TransformationPointFit(</span>
<span class="fc" id="L219">            params.copy(), nMatched,</span>
            difFromModelWeighted, stDevFromModelWeighted, tolTransX, tolTransY);

<span class="fc" id="L222">        fit.setMaximumNumberMatchable(nMaxMatchableSum);</span>
        
<span class="fc" id="L224">        return fit;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
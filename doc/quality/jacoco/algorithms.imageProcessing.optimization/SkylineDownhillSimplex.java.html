<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SkylineDownhillSimplex.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">algorithms.imageProcessing.optimization</a> &gt; <span class="el_source">SkylineDownhillSimplex.java</span></div><h1>SkylineDownhillSimplex.java</h1><pre class="source lang-java linenums">package algorithms.imageProcessing.optimization;

import algorithms.imageProcessing.GreyscaleImage;
import algorithms.imageProcessing.ImageExt;
import algorithms.imageProcessing.SkylineExtractor;
import algorithms.util.PairInt;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Logger;

/**
 *
 * @author nichole
 */
public class SkylineDownhillSimplex {
    
    private final List&lt;ImageExt&gt; images;
    private final List&lt;GreyscaleImage&gt; thetaImages;
    private final List&lt;Set&lt;PairInt&gt;&gt; seedPoints;
    private final List&lt;Set&lt;PairInt&gt;&gt; excludePoints;
    private final List&lt;Set&lt;PairInt&gt;&gt; expectedPoints;
    private final List&lt;Set&lt;PairInt&gt;&gt; expectedBorderPoints;
    private final ANDedClauses[] clauses;
    private final ANDedClauses[] coeffLowerLimits;
    private final ANDedClauses[] coeffUpperLimits;
    
<span class="nc" id="L36">    private Logger log = Logger.getLogger(this.getClass().getName());</span>
    
    public SkylineDownhillSimplex(List&lt;ImageExt&gt; images, 
        List&lt;GreyscaleImage&gt; thetaImages, 
        List&lt;Set&lt;PairInt&gt;&gt; seedPoints, List&lt;Set&lt;PairInt&gt;&gt; excludePoints, 
        List&lt;Set&lt;PairInt&gt;&gt; expectedPoints, 
        List&lt;Set&lt;PairInt&gt;&gt; expectedBorderPoints,
        ANDedClauses[] clauses,
<span class="nc" id="L44">        ANDedClauses[] coeffLowerLimits, ANDedClauses[] coeffUpperLimits) {</span>
        
<span class="nc bnc" id="L46" title="All 2 branches missed.">        if (images == null) {</span>
<span class="nc" id="L47">            throw new IllegalArgumentException(&quot;images cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L49" title="All 2 branches missed.">        if (thetaImages == null) {</span>
<span class="nc" id="L50">            throw new IllegalArgumentException(&quot;thetaImages cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L52" title="All 2 branches missed.">        if (seedPoints == null) {</span>
<span class="nc" id="L53">            throw new IllegalArgumentException(&quot;seedPoints cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L55" title="All 2 branches missed.">        if (excludePoints == null) {</span>
<span class="nc" id="L56">            throw new IllegalArgumentException(&quot;excludePoints cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L58" title="All 2 branches missed.">        if (expectedPoints == null) {</span>
<span class="nc" id="L59">            throw new IllegalArgumentException(&quot;expectedPoints cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L61" title="All 2 branches missed.">        if (expectedBorderPoints == null) {</span>
<span class="nc" id="L62">            throw new IllegalArgumentException(</span>
                &quot;expectedBorderPoints cannot be null&quot;);
        }
<span class="nc bnc" id="L65" title="All 2 branches missed.">        if (clauses == null) {</span>
<span class="nc" id="L66">            throw new IllegalArgumentException(&quot;clauses cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L68" title="All 2 branches missed.">        if (coeffLowerLimits == null) {</span>
<span class="nc" id="L69">            throw new IllegalArgumentException(&quot;coeffLowerLimits cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L71" title="All 2 branches missed.">        if (coeffUpperLimits == null) {</span>
<span class="nc" id="L72">            throw new IllegalArgumentException(&quot;coeffUpperLimits cannot be null&quot;);</span>
        }
        
<span class="nc" id="L75">        this.images = images; </span>
<span class="nc" id="L76">        this.thetaImages = thetaImages;</span>
<span class="nc" id="L77">        this.seedPoints = seedPoints;</span>
<span class="nc" id="L78">        this.excludePoints = excludePoints;</span>
<span class="nc" id="L79">        this.expectedPoints = expectedPoints;</span>
<span class="nc" id="L80">        this.expectedBorderPoints = expectedBorderPoints;</span>
<span class="nc" id="L81">        this.clauses = clauses;</span>
<span class="nc" id="L82">        this.coeffLowerLimits = coeffLowerLimits;</span>
<span class="nc" id="L83">        this.coeffUpperLimits = coeffUpperLimits;</span>
<span class="nc" id="L84">    }</span>
    
    protected SkylineFits process(SkylineExtractor skylineExtractor,
        ANDedClauses[] c) {

<span class="nc" id="L89">        SkylineFits fit = new SkylineFits();</span>
<span class="nc" id="L90">        List&lt;SetComparisonResults&gt; results = new ArrayList&lt;SetComparisonResults&gt;();</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">        for (int i = 0; i &lt; images.size(); i++) {</span>
<span class="nc" id="L92">            SkylineFits tFit = process(skylineExtractor, c, i);</span>
<span class="nc" id="L93">            SetComparisonResults result = tFit.results;</span>
<span class="nc" id="L94">            results.add(result);</span>
        }
<span class="nc" id="L96">        SetComparisonResults result = new SetComparisonResults(results);</span>
<span class="nc" id="L97">        fit.clauses = c;</span>
<span class="nc" id="L98">        fit.results = result;</span>

<span class="nc" id="L100">        return fit;</span>
    }
    
    protected SkylineFits process(SkylineExtractor skylineExtractor,
        ANDedClauses[] clauses, int imageIndex) {

<span class="nc" id="L106">        ImageExt img = images.get(imageIndex);</span>
<span class="nc" id="L107">        GreyscaleImage thetaImg = thetaImages.get(imageIndex);</span>
<span class="nc" id="L108">        Set&lt;PairInt&gt; skyPoints = new HashSet&lt;PairInt&gt;(seedPoints.get(imageIndex));</span>
<span class="nc" id="L109">        Set&lt;PairInt&gt; exclude = excludePoints.get(imageIndex);</span>
<span class="nc" id="L110">        Set&lt;PairInt&gt; expected = expectedPoints.get(imageIndex);</span>
<span class="nc" id="L111">        Set&lt;PairInt&gt; expectedBorder = expectedBorderPoints.get(imageIndex);</span>

<span class="nc" id="L113">        skylineExtractor.findClouds(skyPoints, exclude, img, thetaImg,</span>
            clauses);
        
<span class="nc" id="L116">        Set&lt;PairInt&gt; outputEmbeddedGapPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L117">        Set&lt;PairInt&gt; outputBorderPoints = new HashSet&lt;PairInt&gt;();</span>
<span class="nc" id="L118">        SkylineExtractor.getEmbeddedAndBorderPoints(skyPoints,</span>
<span class="nc" id="L119">            thetaImg.getWidth(), thetaImg.getHeight(), </span>
            outputEmbeddedGapPoints, outputBorderPoints);
        
<span class="nc" id="L122">        SetCompare setCompare = new SetCompare();</span>
        
<span class="nc" id="L124">        SetComparisonResults results = setCompare.compare(expected, skyPoints,</span>
            expectedBorder, outputBorderPoints);

<span class="nc" id="L127">        SkylineFits fit = new SkylineFits();</span>
<span class="nc" id="L128">        fit.results = results;</span>
<span class="nc" id="L129">        fit.clauses = clauses;</span>
        
<span class="nc" id="L131">        return fit;</span>
    }
    
    public SkylineFits fit() throws NoSuchAlgorithmException {
                
<span class="nc" id="L136">        SkylineExtractor skylineExtractor = new SkylineExtractor();</span>
                
        //TODO: edit convergence.  it's the fraction of matched to expected matches.
<span class="nc" id="L139">        float convergence = 1.0f;</span>
      
<span class="nc" id="L141">        int nStarterPoints = 1000;</span>
        
<span class="nc" id="L143">        SkylineFits[] fits = createStarterPoints(skylineExtractor,</span>
            nStarterPoints);
        
<span class="nc" id="L146">        int nMaxIter = 50;//100;</span>
<span class="nc" id="L147">        int nIter = 0;</span>
        
<span class="nc" id="L149">        int bestFitIdx = 0;</span>
<span class="nc" id="L150">        int worstFitIdx = fits.length - 1;</span>

<span class="nc" id="L152">        SetComparisonResults lastBest = null;</span>
<span class="nc" id="L153">        int nIterSameMin = 0;</span>
        
<span class="nc" id="L155">        float alpha = 1.0f;//1   // &gt; 0</span>
<span class="nc" id="L156">        float gamma = 2;   // &gt; 1</span>
<span class="nc" id="L157">        float beta = 0.5f; </span>
<span class="nc" id="L158">        float tau = 0.5f;</span>
        
<span class="nc" id="L160">        boolean go = true;</span>
        
<span class="nc bnc" id="L162" title="All 4 branches missed.">        while (go &amp;&amp; (nIter &lt; nMaxIter)) {</span>

            // best matches should be at smaller indexes
<span class="nc" id="L165">            Arrays.sort(fits, 0, (fits.length - 1));</span>
            
<span class="nc bnc" id="L167" title="All 4 branches missed.">            if ((nIter == 0) &amp;&amp; (nStarterPoints &gt; 3)) {</span>
<span class="nc" id="L168">                nStarterPoints = 10;</span>
<span class="nc" id="L169">                fits = Arrays.copyOf(fits, nStarterPoints);</span>
<span class="nc" id="L170">                worstFitIdx = nStarterPoints - 1;</span>
            }
            
<span class="nc bnc" id="L173" title="All 2 branches missed.">            if ((lastBest != null) &amp;&amp; </span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">                (lastBest.compareTo(fits[bestFitIdx].results) == 0)) {</span>
                
<span class="nc" id="L176">                nIterSameMin++;</span>
                
                /*
                if (nIterSameMin &gt;= 15) {
                    break;
                }*/
                
            } else {
<span class="nc" id="L184">                nIterSameMin = 0;</span>
            }
<span class="nc" id="L186">            lastBest = fits[bestFitIdx].results;</span>
            
<span class="nc" id="L188">            float[][] summedCoeff = sumAllButLastCoefficients(fits);</span>
            
            //&quot;Reflection&quot;
<span class="nc" id="L191">            ANDedClauses[] tClauses = reflect(fits[worstFitIdx], summedCoeff, </span>
                alpha);
            
<span class="nc" id="L194">            SkylineFits fitReflected = process(skylineExtractor, tClauses);</span>

<span class="nc" id="L196">            int comp0 = fits[bestFitIdx].compareTo(fitReflected);</span>
<span class="nc" id="L197">            int compLast = fits[worstFitIdx].compareTo(fitReflected);</span>
            
<span class="nc bnc" id="L199" title="All 4 branches missed.">            if ((comp0 &lt; 1) &amp;&amp; (compLast == 1)) {</span>

                // replace last with f_refl
<span class="nc" id="L202">                fits[worstFitIdx] = fitReflected;</span>

<span class="nc bnc" id="L204" title="All 2 branches missed.">            } else if (comp0 == 1) {</span>

                // reflected is better than best fit, so &quot;expand&quot;
                // &quot;Expansion&quot;
<span class="nc" id="L208">                tClauses = expand(fitReflected, summedCoeff, -1*gamma);</span>

<span class="nc" id="L210">                SkylineFits fitExpansion = process(skylineExtractor, tClauses);</span>
                    
<span class="nc" id="L212">                int compR = fitReflected.compareTo(fitExpansion);</span>
                
<span class="nc bnc" id="L214" title="All 2 branches missed.">                if (compR == 1) {</span>

                    // expansion fit is better than reflected fit
<span class="nc" id="L217">                    fits[worstFitIdx] = fitExpansion;</span>

                } else {

<span class="nc" id="L221">                    fits[worstFitIdx] = fitReflected;</span>
                }

<span class="nc bnc" id="L224" title="All 2 branches missed.">            } else if (compLast &lt; 1) {</span>
                
                // reflected fit is worse than the worst (last) fit, so contract
                // &quot;Contraction&quot;
<span class="nc" id="L228">                tClauses = contract(fits[worstFitIdx], summedCoeff, -1*beta);</span>
                    
<span class="nc" id="L230">                SkylineFits fitContraction = process(skylineExtractor, tClauses);</span>
                    
<span class="nc" id="L232">                int compC = fits[worstFitIdx].compareTo(fitContraction);</span>

<span class="nc bnc" id="L234" title="All 2 branches missed.">                if (compC &gt; -1) {</span>

<span class="nc" id="L236">                    fits[worstFitIdx] = fitContraction;</span>

                } else {
                                 
                    // &quot;Reduction&quot;
<span class="nc bnc" id="L241" title="All 2 branches missed.">                    for (int i = 1; i &lt; fits.length; i++) {</span>

<span class="nc" id="L243">                        tClauses = reduce(fits[bestFitIdx], fits[i], tau);</span>

<span class="nc" id="L245">                        SkylineFits fitReduction = process(skylineExtractor, </span>
                            tClauses);

                        //TODO: consider what to do when solution is out of
                        // bounds
<span class="nc" id="L250">                        fits[i] = fitReduction;</span>
                    }
                }
            }

<span class="nc" id="L255">            log.info(&quot;best fit so far: &quot; + </span>
                fits[bestFitIdx].results.numberMatchedDivExpected);
            
<span class="nc" id="L258">            nIter++;</span>
            
            // convergence is when overrun is zero and number matched is within
            // some limit
            /*if ((fits[bestFitIdx].results.numberOverrunDivExpected == 0) &amp;&amp;
                (fits[bestFitIdx].results.numberMatchedDivExpected == convergence)) {
                go = false;
            }*/
<span class="nc" id="L266">        }</span>
        
<span class="nc" id="L268">        System.out.println(&quot;NITER=&quot; + nIter);</span>
        
<span class="nc" id="L270">        return fits[bestFitIdx];</span>
    }

    private SkylineFits[] createStarterPoints(SkylineExtractor skylineExtractor,
        int nStarterPoints) throws NoSuchAlgorithmException {
                          
        /*
        what pattern to use to alter ANDedClauses[]?
        -- unaltered ANDedClauses[]
        -- ANDedClauses[] adjusted to all lower limits.
        -- ANDedClauses[] adjusted all all higher limits.
        -- 4 divisions between the higher and lower limits?
        
        that's 7 &quot;starter points&quot;, but the values are not representing the
        possible mix of ranges very well, so might need to sample that randomly
        by mixing the combinations of the modified coefficients and increase
        the number of starter points to 20 or so.  
        for example, to avoid all of the lowest bounds being present in one
        set of clauses, a random mix would put some of them in each possibly.
        
        the reason for mixing this small set of coefficients is that the 
        downill simplex, when it alters the coefficients, performs the same changes
        on all of the coefficients in that starter point's list of coefficients, 
        so an &quot;all low bounds&quot; when altered
        might not find the local best for all 40 something coefficients.
        
        With so many parameters, the Nelder-Maede seems like one of the only
        feasible choices for optimization, but it requires more starter points 
        and good bounds to succeed for this use.
        */
        
<span class="nc" id="L301">        SecureRandom sr = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span>
<span class="nc" id="L302">        sr.setSeed(System.nanoTime());</span>
        
<span class="nc" id="L304">        ANDedClauses[][] starterPointClauses = new ANDedClauses[nStarterPoints][];</span>
<span class="nc" id="L305">        starterPointClauses[0] = copy(clauses);</span>
        
<span class="nc bnc" id="L307" title="All 2 branches missed.">        for (int i = 1; i &lt; nStarterPoints; i++) {</span>
            
<span class="nc" id="L309">            starterPointClauses[i] = copy(clauses);</span>
            
<span class="nc bnc" id="L311" title="All 2 branches missed.">            for (int ii = 0; ii &lt; starterPointClauses[i].length; ii++) {</span>
                
<span class="nc" id="L313">                ANDedClauses clause = starterPointClauses[i][ii];</span>
                
<span class="nc" id="L315">                ANDedClauses clauseLowerLimits = coeffLowerLimits[ii];</span>
                
<span class="nc" id="L317">                ANDedClauses clauseUpperLimits = coeffUpperLimits[ii];</span>
                
<span class="nc bnc" id="L319" title="All 2 branches missed.">                for (int jj = 0; jj &lt; clause.coefficients.length; jj++) {</span>
<span class="nc" id="L320">                    float coeff = clause.coefficients[jj];</span>
                    // pick randomly between low bounds, high bounds, center,
                    // or random between bounds
<span class="nc" id="L323">                    int type = sr.nextInt(4);</span>
<span class="nc" id="L324">                    type = 3;</span>
<span class="nc bnc" id="L325" title="All 4 branches missed.">                    switch(type) {</span>
                        case 0:
<span class="nc" id="L327">                            clause.coefficients[jj] = clauseLowerLimits.coefficients[jj];</span>
<span class="nc" id="L328">                            break;</span>
                        case 1:
<span class="nc" id="L330">                            clause.coefficients[jj] = clauseUpperLimits.coefficients[jj];</span>
<span class="nc" id="L331">                            break;</span>
                        case 2:
                            //remain the same
<span class="nc" id="L334">                            break;</span>
                        default: {
<span class="nc" id="L336">                            float range = clauseUpperLimits.coefficients[jj] -</span>
                                clauseLowerLimits.coefficients[jj];
                            // dividing the range by 100 and choosing randomly
                            // between those marks
<span class="nc" id="L340">                            int d = sr.nextInt(10);</span>
<span class="nc" id="L341">                            clause.coefficients[jj] = </span>
                                (float)(clauseLowerLimits.coefficients[jj] +
                                ((float)d)*(range/10.));
<span class="nc" id="L344">                            break;</span>
                        }
                    }
                }
                
<span class="nc bnc" id="L349" title="All 2 branches missed.">                if (!clause.customCoefficientVariables.isEmpty()) {</span>
                
<span class="nc" id="L351">                    Iterator&lt;Entry&lt;Integer, Float&gt;&gt; iter0 = </span>
<span class="nc" id="L352">                        clause.customCoefficientVariables.entrySet().iterator();</span>
                    
<span class="nc" id="L354">                    Map&lt;Integer, Float&gt; tMap = new HashMap&lt;Integer, Float&gt;(</span>
                        clause.customCoefficientVariables);
                                        
<span class="nc bnc" id="L357" title="All 2 branches missed.">                    while (iter0.hasNext()) {</span>

<span class="nc" id="L359">                        Entry&lt;Integer, Float&gt; entry = iter0.next();</span>

<span class="nc" id="L361">                        Integer coeffIndex = entry.getKey();</span>
                                                
<span class="nc" id="L363">                        float lower = </span>
                            clauseLowerLimits.customCoefficientVariables
<span class="nc" id="L365">                                .get(coeffIndex);</span>
                        
<span class="nc" id="L367">                        float upper = </span>
                            clauseUpperLimits.customCoefficientVariables
<span class="nc" id="L369">                                .get(coeffIndex);</span>
                        
<span class="nc" id="L371">                        float range = upper - lower;</span>
                        // dividing the range by 100 and choosing randomly
                        // between those marks
<span class="nc" id="L374">                        int d = sr.nextInt(10);</span>
<span class="nc" id="L375">                        float coeffM = (float)(lower + ((float)d)*(range/10.));</span>

<span class="nc" id="L377">                        tMap.put(coeffIndex, Float.valueOf(coeffM));</span>
<span class="nc" id="L378">                    }</span>

<span class="nc" id="L380">                    clause.customCoefficientVariables.putAll(tMap);</span>
                }
            }
        }        
        
<span class="nc" id="L385">        SkylineFits[] fits = new SkylineFits[nStarterPoints];</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">        for (int idx = 0; idx &lt; fits.length; idx++) { </span>
<span class="nc" id="L387">            SkylineFits fit = process(skylineExtractor, starterPointClauses[idx]);</span>
<span class="nc" id="L388">            fits[idx] = fit;</span>
        }
        
<span class="nc" id="L391">        return fits;</span>
    }

    private float[][] sumAllButLastCoefficients(SkylineFits[] fits) {
        
<span class="nc" id="L396">        int n = 0;</span>
<span class="nc" id="L397">        SkylineFits fit = fits[0];</span>
<span class="nc" id="L398">        int nClauses = fit.clauses.length;</span>
<span class="nc" id="L399">        float[][] avgCoeffs = new float[nClauses][];</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">        for (int clauseIdx = 0; clauseIdx &lt; nClauses; clauseIdx++) {</span>
            
<span class="nc" id="L402">            int nCoefficients = clauses[clauseIdx].coefficients.length;</span>
            
<span class="nc" id="L404">            avgCoeffs[clauseIdx] = new float[nCoefficients];</span>
            
<span class="nc bnc" id="L406" title="All 2 branches missed.">            for (int clauseCoeffIdx = 0; clauseCoeffIdx &lt; nCoefficients; </span>
<span class="nc" id="L407">                clauseCoeffIdx++) {</span>
                
                // iterate over each clauseIdx and each clauseCoeffIdx
                // for each fit in fits.
<span class="nc" id="L411">                double sumCoeff = 0;</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">                for (int fitIdx = 0; fitIdx &lt; fits.length; fitIdx++) {</span>
<span class="nc" id="L413">                    fit = fits[fitIdx];</span>
<span class="nc" id="L414">                    float coeff = fit.clauses[clauseIdx].coefficients[clauseCoeffIdx];</span>
<span class="nc" id="L415">                    sumCoeff += coeff;</span>
                }
<span class="nc" id="L417">                avgCoeffs[clauseIdx][clauseCoeffIdx] = (float)(sumCoeff/(float)fits.length);</span>
            }
        }
        
<span class="nc" id="L421">        return avgCoeffs;</span>
    }

    /**
     * perform &quot;reflection&quot; to change each coefficient using pattern
     *     averagedCoeff[i] + (alpha * (averagedCoeff[i] - fit.coefficient)).
     *
     * @param skylineFits
     * @param summedCoeff
     * @param alpha
     * @return 
     */
    private ANDedClauses[] reflect(SkylineFits fit, float[][] averagedCoeff, 
        float alpha) {
         
<span class="nc" id="L436">        ANDedClauses[] tClauses = performAction(fit, averagedCoeff, alpha);</span>
        
<span class="nc" id="L438">        return tClauses;</span>
    }

    /**
     * perform &quot;expansion&quot; to change each coefficient using pattern
     *     averagedCoeff[i] + (gamma * (averagedCoeff[i] - fit.coefficient)).
     *
     * @param skylineFits
     * @param averagedCoeff
     * @param alpha
     * @return 
     */
    private ANDedClauses[] expand(SkylineFits fit, 
        float[][] averagedCoeff, float gamma) {
       
<span class="nc" id="L453">        ANDedClauses[] tClauses = performAction(fit, averagedCoeff, gamma);</span>
        
<span class="nc" id="L455">        return tClauses;</span>
    }
    
    /**
     * perform &quot;contraction&quot; to change each coefficient using pattern
     *     averagedCoeff[i] + (beta * (averagedCoeff[i] - fit.coefficient)).
     *
     * @param skylineFits
     * @param averagedCoeff
     * @param alpha
     * @return 
     */
    private ANDedClauses[] contract(SkylineFits fit, 
        float[][] averagedCoeff, float beta) {
                
<span class="nc" id="L470">        ANDedClauses[] tClauses = performAction(fit, averagedCoeff, beta);</span>
        
<span class="nc" id="L472">        return tClauses;</span>
    }
    
    /**
     * perform &quot;reduction&quot; to change each coefficient using pattern
     *    bestFit + (tau * (indivFit - bestFit)).
     * @param skylineFits
     * @param averagedCoeff
     * @param alpha
     * @return 
     */
    private ANDedClauses[] reduce(SkylineFits bestFit, SkylineFits fitI, 
        float tau) {
        
<span class="nc" id="L486">        ANDedClauses[] bestClauses = copy(bestFit.clauses);</span>
         
<span class="nc bnc" id="L488" title="All 2 branches missed.">        for (int clauseIdx = 0; clauseIdx &lt; bestClauses.length; clauseIdx++) {</span>
            
<span class="nc" id="L490">            ANDedClauses clauseBest = bestClauses[clauseIdx];</span>
            
<span class="nc" id="L492">            ANDedClauses clauseI = fitI.clauses[clauseIdx];</span>
            
<span class="nc bnc" id="L494" title="All 2 branches missed.">            for (int clauseCoeffIdx = 0; clauseCoeffIdx &lt; </span>
<span class="nc" id="L495">                clauseBest.coefficients.length; clauseCoeffIdx++) {</span>
                
<span class="nc" id="L497">                float coeffBest = clauseBest.coefficients[clauseCoeffIdx];</span>
                
<span class="nc" id="L499">                float coeffI = clauseI.coefficients[clauseCoeffIdx];</span>
                
<span class="nc" id="L501">                float coeffM = coeffBest + (tau * (coeffI - coeffBest));</span>
                
<span class="nc" id="L503">                bestClauses[clauseIdx].coefficients[clauseCoeffIdx] = coeffM;</span>
            }
            
<span class="nc bnc" id="L506" title="All 2 branches missed.">            if (!clauseI.customCoefficientVariables.isEmpty()) {</span>
                
<span class="nc" id="L508">                Iterator&lt;Entry&lt;Integer, Float&gt;&gt; iter = </span>
<span class="nc" id="L509">                    clauseI.customCoefficientVariables.entrySet().iterator();</span>
                
<span class="nc" id="L511">                Map&lt;Integer, Float&gt; tMap = new HashMap&lt;Integer, Float&gt;(</span>
                    clauseI.customCoefficientVariables);
                
<span class="nc bnc" id="L514" title="All 2 branches missed.">                while (iter.hasNext()) {</span>
                    
<span class="nc" id="L516">                    Entry&lt;Integer, Float&gt; entry = iter.next();</span>
                    
<span class="nc" id="L518">                    Integer coeffIndex = entry.getKey();</span>
                    
<span class="nc" id="L520">                    float coeffI = entry.getValue().floatValue();</span>
                    
<span class="nc" id="L522">                    float coeffBest = clauseBest.customCoefficientVariables.get(</span>
                        coeffIndex);
                    
<span class="nc" id="L525">                    float coeffM = coeffBest + (tau * (coeffI - coeffBest));</span>
                    
<span class="nc" id="L527">                    tMap.put(coeffIndex, Float.valueOf(coeffM));</span>
<span class="nc" id="L528">                }</span>
                
<span class="nc" id="L530">                bestClauses[clauseIdx].customCoefficientVariables.putAll(tMap);</span>
            }
            
        }
        
<span class="nc" id="L535">        return bestClauses;</span>
    }
    
    private ANDedClauses[] performAction(SkylineFits fit, float[][] averagedCoeff, 
        float factor) {
        
<span class="nc" id="L541">        ANDedClauses[] tClauses = copy(fit.clauses);</span>
         
<span class="nc bnc" id="L543" title="All 2 branches missed.">        for (int clauseIdx = 0; clauseIdx &lt; tClauses.length; clauseIdx++) {</span>
            
<span class="nc" id="L545">            ANDedClauses clause = tClauses[clauseIdx];</span>
            
<span class="nc bnc" id="L547" title="All 2 branches missed.">            for (int clauseCoeffIdx = 0; clauseCoeffIdx &lt; </span>
<span class="nc" id="L548">                clause.coefficients.length; clauseCoeffIdx++) {</span>
                
<span class="nc" id="L550">                float coeff = averagedCoeff[clauseIdx][clauseCoeffIdx];</span>
                
<span class="nc" id="L552">                float coeffM = coeff + (factor * </span>
                    (coeff - fit.clauses[clauseIdx].coefficients[clauseCoeffIdx]));
                
<span class="nc" id="L555">                tClauses[clauseIdx].coefficients[clauseCoeffIdx] = coeffM;</span>
            }
            
<span class="nc bnc" id="L558" title="All 2 branches missed.">            if (!clause.customCoefficientVariables.isEmpty()) {</span>
                
<span class="nc" id="L560">                Iterator&lt;Entry&lt;Integer, Float&gt;&gt; iter = </span>
<span class="nc" id="L561">                    clause.customCoefficientVariables.entrySet().iterator();</span>
                
<span class="nc" id="L563">                Map&lt;Integer, Float&gt; tMap = new HashMap&lt;Integer, Float&gt;(</span>
                    clause.customCoefficientVariables);
                
<span class="nc bnc" id="L566" title="All 2 branches missed.">                while (iter.hasNext()) {</span>
                    
<span class="nc" id="L568">                    Entry&lt;Integer, Float&gt; entry = iter.next();</span>
                    
<span class="nc" id="L570">                    Integer coeffIndex = entry.getKey();</span>
                    
<span class="nc" id="L572">                    float coeff = entry.getValue().floatValue();</span>
                    
<span class="nc" id="L574">                    float coeffM = coeff + (factor * </span>
<span class="nc" id="L575">                        (coeff - fit.clauses[clauseIdx].customCoefficientVariables.get(coeffIndex)));</span>
                    
<span class="nc" id="L577">                    tMap.put(coeffIndex, Float.valueOf(coeffM));</span>
<span class="nc" id="L578">                }</span>
                
<span class="nc" id="L580">                fit.clauses[clauseIdx].customCoefficientVariables.putAll(tMap);</span>
            }
        }
        
<span class="nc" id="L584">        return tClauses;</span>
    }
    
    private boolean isWithinBounds(SkylineFits fit) {
        
<span class="nc" id="L589">        ANDedClauses[] tClauses = fit.clauses;</span>
         
<span class="nc bnc" id="L591" title="All 2 branches missed.">        for (int clauseIdx = 0; clauseIdx &lt; tClauses.length; clauseIdx++) {</span>
            
<span class="nc" id="L593">            ANDedClauses clause = tClauses[clauseIdx];</span>
            
<span class="nc" id="L595">            ANDedClauses clauseLowerLimits = coeffLowerLimits[clauseIdx];</span>
            
<span class="nc" id="L597">            ANDedClauses clauseUpperLimits = coeffUpperLimits[clauseIdx];</span>
            
<span class="nc bnc" id="L599" title="All 2 branches missed.">            for (int clauseCoeffIdx = 0; clauseCoeffIdx &lt; </span>
<span class="nc" id="L600">                clause.coefficients.length; clauseCoeffIdx++) {</span>
                
<span class="nc" id="L602">                float coeff = clause.coefficients[clauseCoeffIdx];</span>
                
<span class="nc" id="L604">                float upper = clauseLowerLimits.coefficients[clauseCoeffIdx];</span>
                
<span class="nc" id="L606">                float lower = clauseUpperLimits.coefficients[clauseCoeffIdx];</span>
                
<span class="nc bnc" id="L608" title="All 4 branches missed.">                if ((coeff &lt; lower) || (coeff &gt; upper)) {</span>
<span class="nc" id="L609">                    return false;</span>
                }
            }
        }
        
<span class="nc" id="L614">       return true;</span>
    }

    private boolean fitIsBetter(SkylineFits fit, SkylineFits compareToFit) {
        
        // -1 is fit is better than compareToFit
<span class="nc" id="L620">        int comp = fit.compareTo(compareToFit);</span>
        
<span class="nc bnc" id="L622" title="All 2 branches missed.">        return (comp &gt; 0);</span>
    }

    private ANDedClauses[] copy(ANDedClauses[] clauses) {
        
<span class="nc" id="L627">        ANDedClauses[] t = new ANDedClauses[clauses.length];</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">        for (int i = 0; i &lt; clauses.length; i++) {</span>
<span class="nc" id="L629">            t[i] = clauses[i].copy();</span>
        }
        
<span class="nc" id="L632">        return t;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>
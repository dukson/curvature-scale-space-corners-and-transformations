<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_51) on Mon Dec 01 22:03:18 PST 2014 -->
<title>PointMatcher</title>
<meta name="date" content="2014-12-01">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="PointMatcher";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../algorithms/imageProcessing/NextContour.html" title="class in algorithms.imageProcessing"><span class="strong">Prev Class</span></a></li>
<li><a href="../../algorithms/imageProcessing/ScaleSpaceCurvature.html" title="class in algorithms.imageProcessing"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?algorithms/imageProcessing/PointMatcher.html" target="_top">Frames</a></li>
<li><a href="PointMatcher.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">algorithms.imageProcessing</div>
<h2 title="Class PointMatcher" class="title">Class PointMatcher</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>algorithms.imageProcessing.PointMatcher</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public final class <span class="strong">PointMatcher</span>
extends java.lang.Object</pre>
<div class="block">class to match the points extracted from two images.
 
 the transformation parameters of translation, rotation and scale are 
 found given the two sets of points.
 
 <pre>
   Details of determining the transformation from points.

   After points are matched:
       Estimating scale:
           Take 2 pairs of points in both datasets and compute the distance 
           between them and then take the ratio:

           scale = (distance between pair in set 1) 
                   / (distance between pair in set 2)

           Note: scale is roughly determined from contour matching too in the
              inflection matcher.

       Estimating rotation:
           Take the same 2 pairs and determine the difference in their angles:
               tan(theta) = delta y / delta x

           rotation = atan((delta y between pair in set 1)
                          /(delta x between pair in set 1)) 
                      -
                      atan((delta y between pair in set 2)
                          /(delta x between pair in set 2))

       Estimate translation:
           Performed on one point in set 1 with its candidate match in set 2:
           From the full transformation equation, we can rewrite:
               transX = xt0 - xc*scale - 
                   (((x0-xc)*scale*math.cos(theta)) + ((y0-yc)*scale*math.sin(theta)))

               transY = yt0 - yc*scale - 
                    ((-(x0-xc)*scale*math.sin(theta)) + ((y0-yc)*scale*math.cos(theta)))

               where (xc, yc) is the center of the first image

 Matching the points:

   For the contour matching, we were able to choose subsets of the entire
   sets of contours for better matching characteristics (subsets that had larger
   sigma values for their peaks could be used).

   For the points given here, there isn't a clear indicator for a subset that 
   could be used preferably so that all nodes might not need to be visited.

   The need to use pairs of points in set1 matched against pairs in set 2
   means that if one tries every combination of pairs, the runtime complexity 
   is exponential.

       number of ways to make pairs in set 1 times the number of ways to make
       pairs in set 2 = 
             n_1!            n_2!
         ------------  X  ------------
         2*(n_1 - 2)!     2*(n_2 - 2)!

   This is not feasible as soon as the sets get larger than a dozen points.

   Alternately, one could try a search algorithm to visit the space of all 
   possible combinations of parameters instead of all combinations of subsets 
   of pairs.

        max translation x possible = width of image 2
        max translation y possible = height of image 2
        max scale is set to some reasonable number like 10?
        max rotation is 1 degree changes = 360 (or quadrants?)

        then total number of permutations 
            = maxTransX * maxTransY * maxScale * 360
            = 1000 * 500 * 10 * 360 = 1.8 billion for pure grid search over 
              parameter space

        then trying the parameters on all points puts another factor into there
        of nPoints set 1 * nPoints set 2.

  Note, because the cosine and sine terms in the transformation equation due to
  rotation work against one another and don't proceed in a total combined
  single direction with theta, we can't use a gradient descent solver.

       (note, this hasn't been edited for positive Y up yet)
       positive Y is down 
       positive X is right
       positive theta starts from Y=0, X>=0 and proceeds CW
                270
           QIII  |  QIV   
                 |
          180--------- 0   +X
                 |   
           QII   |   QI
                 90
                 +Y

  theta        cos(theta)  sin(theta)
  0     0        1.0         0    -----
  30    0.5236   0.87        0.5       |
  45    0.785    0.707       0.707     | QI
  60    1.047    0.5         0.866     |
  90    1.57     0.0         1.0  -----
  120   2.09    -0.5         0.866     | QII
  150   2.618   -0.866       0.5       |
  180   3.1416  -1.0         0.0  -----
  210   3.6652  -0.866      -0.5       | QIII
  240                                  |
  270   4.7124   0.0        -1.0  -----
  300   5.236    0.5        -0.866     | QIV
  330                                  |
                                  -----
  So then, it looks like a grid search over rotation and scale intervals
  followed by fitting for translation to get into the local neighborhood
  of the transformation solution, followed by the use of the 
  Nelder-Mead Downhill Simplex to refine the transformation is a better 
  solution.

  runtime complexity of:

      grid search: nRotationIntervals * nScaleIntervals * nSet1 * nSet2 

      downhill search: not polynomial nor deterministic.  varies by dataset.

     In the searches, if rotation and scale are fixed, and transX and transY 
     are to be found, one can use either:

         (1) compare the offsets implied by each combination of points in set 1
             and set 2.
             for brown_lowe_2003 image1 and image2, the number of corners is
             n1 = 78
             n2 = 88
             n1 * n2 = 5616

             How does one determine the best solution among those translations?  
             One needs an assumed tolerance for the translation, and then to 
             count the number of matches to a point in the 2nd set.
             The best solution has the highest number of matches with the same
             rules for an assumed tolerance and the smallest avg difference
             with predicted positions for matches in set 2.

             For the tolerance, the reasons that translation might be different
             as a function of position in the image might be:
               -- due to rounding to a pixel.  these are very small errors.
               -- due to projection effects for different epipolar geometry 
                  (camera nadir perpendicular to different feature, for example).  
                  these are potentially very large and are not
                  solved in the transformation with this point matcher though a
                  tolerance is made for a small amount of it.  
                  (NOTE however, that once the points are matched, the true 
                  epipolar geometry can be calculated with the StereoProjection 
                  classes).
               -- due to errors in the location of the corner.  this can be due
                  to the edge detector.  these are small errors.
               -- due to image warping such as distortions from the shape of the
                  lens.  one would need a point matcher tailored for the 
                  specific geometric projection.
               -- due to a camera not completely perpendicularly aligned with
                  the optical axis. presumably, this is an extreme case and
                  you'd want better data...

             For the Brown & Lowe 2003 points, 
                 transX=293.1 (stdDev=10.3)
                 transY=14.3 (stdDev=5.9)
             the large standard deviation appears to be due to projection 
             effects.  the skyline is rotated about 13 degrees w.r.t. skyline 
             in second image while the features at the bottom remain horizontal 
             in both.

             The spread in standard deviation appears to be correlated w/
             the image dimensions, as would be expected with projection being 
             the largest reason for a spread in translation.
             That is, the X axis is twice the size of the Y and so are their
             respective standard deviations.

             Could make a generous allowance for projection effects by assuming 
             a maximum present such as that in the Brown & Lowe images, that is 
             image size times an error due to a differential spread 
             over those pixels for a maximum difference in rotation such as 
             20 degrees or something.  For Brown & Lowe images, the tolerance 
             would be number of pixels for dimension times 0.02.

             If there is no reasonable solution using only scale, rotation, and 
             translation, then a more computationally expensive point matcher 
             that solves for epipolar geometry too or a differential rotation
             and associated variance in other parameters
             is needed (and hasn't been implemented 
             here yet).  **OR, even better, an approach using contours and an
             understanding of occlusion (the later possibly requires shape
             identification) can be made with the contour matcher in this 
             project.**
             The contour matcher approach is currently not **commonly**
             possible with this project, because most edges are not closed 
             curves.

    OR

         (2) try every possible combination of translation for X and Y which
             would be width of image 2 in pixels times the height of image 2
             in pixels.
             for brown_lowe_2003 image1 and image2,
             image2 width = 517, height = 374
             w * h = 193358
             so this method is 34 times more

             The best solution among those translations is found in the same
             way as (1) above.
 </pre></div>
<dl><dt><span class="strong">Author:</span></dt>
  <dd>nichole</dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../algorithms/imageProcessing/PointMatcher.html#PointMatcher()">PointMatcher</a></strong>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../algorithms/imageProcessing/TransformationPointFit.html" title="class in algorithms.imageProcessing">TransformationPointFit</a></code></td>
<td class="colLast"><code><strong><a href="../../algorithms/imageProcessing/PointMatcher.html#calculateTransformation(algorithms.util.PairIntArray, algorithms.util.PairIntArray, int, int)">calculateTransformation</a></strong>(<a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set1,
                       <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set2,
                       int&nbsp;image1Width,
                       int&nbsp;image1Height)</code>
<div class="block">calculate the rotation, scale, and translation that can be applied
 to set1 to match points to set2 where the matches are not already known.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../algorithms/imageProcessing/TransformationPointFit.html" title="class in algorithms.imageProcessing">TransformationPointFit</a></code></td>
<td class="colLast"><code><strong><a href="../../algorithms/imageProcessing/PointMatcher.html#calculateTranslation(algorithms.util.PairIntArray, algorithms.util.PairIntArray, double, double, double, double, double, double, int, int)">calculateTranslation</a></strong>(<a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set1,
                    <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set2,
                    double&nbsp;prevNearTransX,
                    double&nbsp;prevNearTransY,
                    double&nbsp;transXTol,
                    double&nbsp;transYTol,
                    double&nbsp;rotation,
                    double&nbsp;scale,
                    int&nbsp;centroidX1,
                    int&nbsp;centroidY1)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../algorithms/imageProcessing/TransformationPointFit.html" title="class in algorithms.imageProcessing">TransformationPointFit</a></code></td>
<td class="colLast"><code><strong><a href="../../algorithms/imageProcessing/PointMatcher.html#calculateTranslation(algorithms.util.PairIntArray, algorithms.util.PairIntArray, double, double, double, double, int, int)">calculateTranslation</a></strong>(<a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set1,
                    <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set2,
                    double&nbsp;transXTol,
                    double&nbsp;transYTol,
                    double&nbsp;rotation,
                    double&nbsp;scale,
                    int&nbsp;centroidX1,
                    int&nbsp;centroidY1)</code>
<div class="block">given the scale, rotation and set 1's reference frame centroids,
 calculate the translation between set1 and set2 assuming that not all
 points will match.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>(package private) double[]</code></td>
<td class="colLast"><code><strong><a href="../../algorithms/imageProcessing/PointMatcher.html#createIntervals(double, double, double)">createIntervals</a></strong>(double&nbsp;start,
               double&nbsp;stop,
               double&nbsp;delta)</code>
<div class="block">create an array of values starting with start and ending before stop
 with separations of size delta.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>(package private) int</code></td>
<td class="colLast"><code><strong><a href="../../algorithms/imageProcessing/PointMatcher.html#populateDiffFromModel(algorithms.util.PairIntArray, algorithms.util.PairIntArray, algorithms.imageProcessing.TransformationParameters, double, double, int, int, double[], int, double[])">populateDiffFromModel</a></strong>(<a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set1,
                     <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set2,
                     <a href="../../algorithms/imageProcessing/TransformationParameters.html" title="class in algorithms.imageProcessing">TransformationParameters</a>&nbsp;params,
                     double&nbsp;transXTol,
                     double&nbsp;transYTol,
                     int&nbsp;centroidX1,
                     int&nbsp;centroidY1,
                     double[]&nbsp;diffFromModel,
                     int&nbsp;diffFromModelOffset,
                     double[]&nbsp;avgDiffModel)</code>
<div class="block">apply the parameters to set1 and find the matches to points in set2
 within the given tolerance for translations.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../algorithms/imageProcessing/TransformationParameters.html" title="class in algorithms.imageProcessing">TransformationParameters</a></code></td>
<td class="colLast"><code><strong><a href="../../algorithms/imageProcessing/PointMatcher.html#refineTransformation(algorithms.util.PairIntArray[], algorithms.util.PairIntArray[], algorithms.imageProcessing.TransformationParameters, int, int, int, int)">refineTransformation</a></strong>(<a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>[]&nbsp;edges1,
                    <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>[]&nbsp;edges2,
                    <a href="../../algorithms/imageProcessing/TransformationParameters.html" title="class in algorithms.imageProcessing">TransformationParameters</a>&nbsp;params,
                    int&nbsp;centroidX1,
                    int&nbsp;centroidY1,
                    int&nbsp;centroidX2,
                    int&nbsp;centroidY2)</code>
<div class="block">refine the transformation params to make a better match of edges1 to
 edges2 where the points within edges in both sets are not necessarily
 1 to 1 matches (that is, the input is not expected to be matched 
 already).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../algorithms/imageProcessing/TransformationPointFit.html" title="class in algorithms.imageProcessing">TransformationPointFit</a></code></td>
<td class="colLast"><code><strong><a href="../../algorithms/imageProcessing/PointMatcher.html#refineTransformationWithDownhillSimplex(algorithms.imageProcessing.TransformationParameters, algorithms.util.PairIntArray, algorithms.util.PairIntArray, int, int)">refineTransformationWithDownhillSimplex</a></strong>(<a href="../../algorithms/imageProcessing/TransformationParameters.html" title="class in algorithms.imageProcessing">TransformationParameters</a>&nbsp;params,
                                       <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set1,
                                       <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set2,
                                       int&nbsp;image1Width,
                                       int&nbsp;image1Height)</code>
<div class="block">refine the transformation params for set1 to better match set2.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>(package private) void</code></td>
<td class="colLast"><code><strong><a href="../../algorithms/imageProcessing/PointMatcher.html#sortByDescendingMatches(algorithms.imageProcessing.TransformationPointFit[], int, int)">sortByDescendingMatches</a></strong>(<a href="../../algorithms/imageProcessing/TransformationPointFit.html" title="class in algorithms.imageProcessing">TransformationPointFit</a>[]&nbsp;fits,
                       int&nbsp;idxLo,
                       int&nbsp;idxHi)</code>
<div class="block">sort the fits by descending number of matches.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>(package private) <a href="../../algorithms/imageProcessing/TransformationPointFit.html" title="class in algorithms.imageProcessing">TransformationPointFit</a></code></td>
<td class="colLast"><code><strong><a href="../../algorithms/imageProcessing/PointMatcher.html#transform(algorithms.util.PairIntArray[], algorithms.util.PairIntArray[], algorithms.imageProcessing.TransformationParameters, double, double, int, int)">transform</a></strong>(<a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>[]&nbsp;edges1,
         <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>[]&nbsp;edges2,
         <a href="../../algorithms/imageProcessing/TransformationParameters.html" title="class in algorithms.imageProcessing">TransformationParameters</a>&nbsp;params,
         double&nbsp;transXTol,
         double&nbsp;transYTol,
         int&nbsp;centroidX1,
         int&nbsp;centroidY1)</code>
<div class="block">apply the parameters to set1 and find the matches to points in set2
 within the given tolerance for translations.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>(package private) <a href="../../algorithms/imageProcessing/TransformationPointFit.html" title="class in algorithms.imageProcessing">TransformationPointFit</a></code></td>
<td class="colLast"><code><strong><a href="../../algorithms/imageProcessing/PointMatcher.html#transform(algorithms.util.PairIntArray, algorithms.util.PairIntArray, double, double, double, double, double, double, int, int)">transform</a></strong>(<a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set1,
         <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set2,
         double&nbsp;scale,
         double&nbsp;rotationInRadians,
         double&nbsp;translationX,
         double&nbsp;translationY,
         double&nbsp;transXTol,
         double&nbsp;transYTol,
         int&nbsp;centroidX1,
         int&nbsp;centroidY1)</code>
<div class="block">apply the parameters to set1 and find the matches to points in set2
 within the given tolerance for translations.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>(package private) <a href="../../algorithms/imageProcessing/TransformationPointFit.html" title="class in algorithms.imageProcessing">TransformationPointFit</a></code></td>
<td class="colLast"><code><strong><a href="../../algorithms/imageProcessing/PointMatcher.html#transform(algorithms.util.PairIntArray, algorithms.util.PairIntArray, algorithms.imageProcessing.TransformationParameters, double, double, int, int)">transform</a></strong>(<a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set1,
         <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set2,
         <a href="../../algorithms/imageProcessing/TransformationParameters.html" title="class in algorithms.imageProcessing">TransformationParameters</a>&nbsp;params,
         double&nbsp;transXTol,
         double&nbsp;transYTol,
         int&nbsp;centroidX1,
         int&nbsp;centroidY1)</code>
<div class="block">apply the parameters to set1 and find the matches to points in set2
 within the given tolerance for translations.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="PointMatcher()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>PointMatcher</h4>
<pre>public&nbsp;PointMatcher()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="calculateTransformation(algorithms.util.PairIntArray, algorithms.util.PairIntArray, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calculateTransformation</h4>
<pre>public&nbsp;<a href="../../algorithms/imageProcessing/TransformationPointFit.html" title="class in algorithms.imageProcessing">TransformationPointFit</a>&nbsp;calculateTransformation(<a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set1,
                                             <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set2,
                                             int&nbsp;image1Width,
                                             int&nbsp;image1Height)</pre>
<div class="block">calculate the rotation, scale, and translation that can be applied
 to set1 to match points to set2 where the matches are not already known.  
 The image1Width and imageHeight are used to create a tolerance in 
 translation for matches.
 
 NOTE: scale has be >= 1, so if one image has a smaller scale, it has to
 be the first set given in arguments.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>set1</code> - set of points such as corners from an image</dd><dd><code>set2</code> - set of points such as corners from another image.</dd><dd><code>image1Width</code> - </dd><dd><code>image1Height</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="transform(algorithms.util.PairIntArray[], algorithms.util.PairIntArray[], algorithms.imageProcessing.TransformationParameters, double, double, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transform</h4>
<pre><a href="../../algorithms/imageProcessing/TransformationPointFit.html" title="class in algorithms.imageProcessing">TransformationPointFit</a>&nbsp;transform(<a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>[]&nbsp;edges1,
                               <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>[]&nbsp;edges2,
                               <a href="../../algorithms/imageProcessing/TransformationParameters.html" title="class in algorithms.imageProcessing">TransformationParameters</a>&nbsp;params,
                               double&nbsp;transXTol,
                               double&nbsp;transYTol,
                               int&nbsp;centroidX1,
                               int&nbsp;centroidY1)</pre>
<div class="block">apply the parameters to set1 and find the matches to points in set2
 within the given tolerance for translations.
 
 NOTE: scale has be >= 1, so if one image has a smaller scale, it has to
 be the first set given in arguments.
 
 ALSO NOTE: if you know a better solution exists for translation 
 parameters that matches fewer points, but has a small avg dist from
 model and smaller standard deviation from the avg dist from model,
 then transXTol and transYTol should be smaller.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>edges1</code> - </dd><dd><code>edges2</code> - </dd><dd><code>params</code> - </dd><dd><code>transXTol</code> - </dd><dd><code>transYTol</code> - </dd><dd><code>centroidX1</code> - </dd><dd><code>centroidY1</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="transform(algorithms.util.PairIntArray, algorithms.util.PairIntArray, double, double, double, double, double, double, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transform</h4>
<pre><a href="../../algorithms/imageProcessing/TransformationPointFit.html" title="class in algorithms.imageProcessing">TransformationPointFit</a>&nbsp;transform(<a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set1,
                               <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set2,
                               double&nbsp;scale,
                               double&nbsp;rotationInRadians,
                               double&nbsp;translationX,
                               double&nbsp;translationY,
                               double&nbsp;transXTol,
                               double&nbsp;transYTol,
                               int&nbsp;centroidX1,
                               int&nbsp;centroidY1)</pre>
<div class="block">apply the parameters to set1 and find the matches to points in set2
 within the given tolerance for translations.
 
 NOTE: scale has be >= 1, so if one image has a smaller scale, it has to
 be the first set given in arguments.
 
 ALSO NOTE: if you know a better solution exists for translation 
 parameters that matches fewer points, but has a small avg dist from
 model and smaller standard deviation from the avg dist from model,
 then transXTol and transYTol should be smaller.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>set1</code> - points matched to set 2</dd><dd><code>set2</code> - points matched to set 1</dd><dd><code>transXTol</code> - </dd><dd><code>transYTol</code> - </dd><dd><code>centroidX1</code> - </dd><dd><code>centroidY1</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="transform(algorithms.util.PairIntArray, algorithms.util.PairIntArray, algorithms.imageProcessing.TransformationParameters, double, double, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transform</h4>
<pre><a href="../../algorithms/imageProcessing/TransformationPointFit.html" title="class in algorithms.imageProcessing">TransformationPointFit</a>&nbsp;transform(<a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set1,
                               <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set2,
                               <a href="../../algorithms/imageProcessing/TransformationParameters.html" title="class in algorithms.imageProcessing">TransformationParameters</a>&nbsp;params,
                               double&nbsp;transXTol,
                               double&nbsp;transYTol,
                               int&nbsp;centroidX1,
                               int&nbsp;centroidY1)</pre>
<div class="block">apply the parameters to set1 and find the matches to points in set2
 within the given tolerance for translations.
 
 NOTE: scale has be >= 1, so if one image has a smaller scale, it has to
 be the first set given in arguments.
 
 ALSO NOTE: if you know a better solution exists for translation 
 parameters that matches fewer points, but has a small avg dist from
 model and smaller standard deviation from the avg dist from model,
 then transXTol and transYTol should be smaller.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>set1</code> - points matched to set 2</dd><dd><code>set2</code> - points matched to set 1</dd><dd><code>params</code> - </dd><dd><code>transXTol</code> - </dd><dd><code>transYTol</code> - </dd><dd><code>centroidX1</code> - </dd><dd><code>centroidY1</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="calculateTranslation(algorithms.util.PairIntArray, algorithms.util.PairIntArray, double, double, double, double, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calculateTranslation</h4>
<pre>public&nbsp;<a href="../../algorithms/imageProcessing/TransformationPointFit.html" title="class in algorithms.imageProcessing">TransformationPointFit</a>&nbsp;calculateTranslation(<a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set1,
                                          <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set2,
                                          double&nbsp;transXTol,
                                          double&nbsp;transYTol,
                                          double&nbsp;rotation,
                                          double&nbsp;scale,
                                          int&nbsp;centroidX1,
                                          int&nbsp;centroidY1)</pre>
<div class="block">given the scale, rotation and set 1's reference frame centroids,
 calculate the translation between set1 and set2 assuming that not all
 points will match.  transXTol and transYTol allow a tolerance when
 matching the predicted position of a point in set2.
 
 It's expected that the invoker of this method is trying to solve for
 translation for sets of points like corners in images.  This assumption
 means that the number of point pair combinations is always far less
 than the pixel combinations of translations over x and y.
 
 NOTE: scale has be >= 1, so if one image has a smaller scale, it has to
 be the first set given in arguments.
 
 ALSO NOTE: if you know a better solution exists for translation 
 parameters that matches fewer points, but has a small avg dist from
 model and smaller standard deviation from the avg dist from model,
 then transXTol and transYTol should be set to a smaller value and passed
 to this method.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>set1</code> - set of points from image 1 to match to image2.</dd><dd><code>set2</code> - set of points from image 2 to be matched with image 1</dd><dd><code>transXTol</code> - tolerance in x for finding a match for translation.
 For example, transXTol = image1.getWidth() * 0.02;</dd><dd><code>transYTol</code> - tolerance in y for finding a match for translation.
 For example, transYTol = image1.getHeight() * 0.02;</dd><dd><code>rotation</code> - given in radians with value between 0 and 2*pi, exclusive</dd><dd><code>scale</code> - </dd><dd><code>centroidX1</code> - the x coordinate of the center of image 1 from which
 set 1 point are from.</dd><dd><code>centroidY1</code> - the y coordinate of the center of image 1 from which
 set 1 point are from.</dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="calculateTranslation(algorithms.util.PairIntArray, algorithms.util.PairIntArray, double, double, double, double, double, double, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calculateTranslation</h4>
<pre>public&nbsp;<a href="../../algorithms/imageProcessing/TransformationPointFit.html" title="class in algorithms.imageProcessing">TransformationPointFit</a>&nbsp;calculateTranslation(<a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set1,
                                          <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set2,
                                          double&nbsp;prevNearTransX,
                                          double&nbsp;prevNearTransY,
                                          double&nbsp;transXTol,
                                          double&nbsp;transYTol,
                                          double&nbsp;rotation,
                                          double&nbsp;scale,
                                          int&nbsp;centroidX1,
                                          int&nbsp;centroidY1)</pre>
</li>
</ul>
<a name="refineTransformationWithDownhillSimplex(algorithms.imageProcessing.TransformationParameters, algorithms.util.PairIntArray, algorithms.util.PairIntArray, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>refineTransformationWithDownhillSimplex</h4>
<pre>public&nbsp;<a href="../../algorithms/imageProcessing/TransformationPointFit.html" title="class in algorithms.imageProcessing">TransformationPointFit</a>&nbsp;refineTransformationWithDownhillSimplex(<a href="../../algorithms/imageProcessing/TransformationParameters.html" title="class in algorithms.imageProcessing">TransformationParameters</a>&nbsp;params,
                                                             <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set1,
                                                             <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set2,
                                                             int&nbsp;image1Width,
                                                             int&nbsp;image1Height)</pre>
<div class="block">refine the transformation params for set1 to better match set2.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>params</code> - </dd><dd><code>set1</code> - </dd><dd><code>set2</code> - </dd><dd><code>image1Width</code> - </dd><dd><code>image1Height</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="refineTransformation(algorithms.util.PairIntArray[], algorithms.util.PairIntArray[], algorithms.imageProcessing.TransformationParameters, int, int, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>refineTransformation</h4>
<pre>public&nbsp;<a href="../../algorithms/imageProcessing/TransformationParameters.html" title="class in algorithms.imageProcessing">TransformationParameters</a>&nbsp;refineTransformation(<a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>[]&nbsp;edges1,
                                            <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>[]&nbsp;edges2,
                                            <a href="../../algorithms/imageProcessing/TransformationParameters.html" title="class in algorithms.imageProcessing">TransformationParameters</a>&nbsp;params,
                                            int&nbsp;centroidX1,
                                            int&nbsp;centroidY1,
                                            int&nbsp;centroidX2,
                                            int&nbsp;centroidY2)</pre>
<div class="block">refine the transformation params to make a better match of edges1 to
 edges2 where the points within edges in both sets are not necessarily
 1 to 1 matches (that is, the input is not expected to be matched 
 already).
 
 TODO: improve transformEdges to find translation for all edges
 via a search method rather than trying all pairs of points.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>edges1</code> - </dd><dd><code>edges2</code> - </dd><dd><code>params</code> - </dd><dd><code>centroidX1</code> - </dd><dd><code>centroidY1</code> - </dd><dd><code>centroidX2</code> - </dd><dd><code>centroidY2</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="populateDiffFromModel(algorithms.util.PairIntArray, algorithms.util.PairIntArray, algorithms.imageProcessing.TransformationParameters, double, double, int, int, double[], int, double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>populateDiffFromModel</h4>
<pre>int&nbsp;populateDiffFromModel(<a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set1,
                        <a href="../../algorithms/util/PairIntArray.html" title="class in algorithms.util">PairIntArray</a>&nbsp;set2,
                        <a href="../../algorithms/imageProcessing/TransformationParameters.html" title="class in algorithms.imageProcessing">TransformationParameters</a>&nbsp;params,
                        double&nbsp;transXTol,
                        double&nbsp;transYTol,
                        int&nbsp;centroidX1,
                        int&nbsp;centroidY1,
                        double[]&nbsp;diffFromModel,
                        int&nbsp;diffFromModelOffset,
                        double[]&nbsp;avgDiffModel)</pre>
<div class="block">apply the parameters to set1 and find the matches to points in set2
 within the given tolerance for translations.
 
 runtime complexity is O(n_set1 * n_set2)
 
 NOTE: scale has be >= 1, so if one image has a smaller scale, it has to
 be the first set given in arguments.
 
 ALSO NOTE: if you know a better solution exists for translation 
 parameters that matches fewer points, but has a small avg dist from
 model and smaller standard deviation from the avg dist from model,
 then transXTol and transYTol should be smaller.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>set1</code> - </dd><dd><code>set2</code> - </dd><dd><code>params</code> - </dd><dd><code>transXTol</code> - </dd><dd><code>transYTol</code> - </dd><dd><code>centroidX1</code> - </dd><dd><code>centroidY1</code> - </dd><dd><code>diffFromModel</code> - output variable holding difference of matched
    points from model</dd><dd><code>diffFromModelOffset</code> - input variable holding the offset in 
 array diffFromModel for which points are added from this method.</dd><dd><code>avgDiffModel</code> - output variable holding the average difference from
 the model.</dd>
<dt><span class="strong">Returns:</span></dt><dd>number of matched points.  returns -1 if the scale is less than 1</dd></dl>
</li>
</ul>
<a name="sortByDescendingMatches(algorithms.imageProcessing.TransformationPointFit[], int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sortByDescendingMatches</h4>
<pre>void&nbsp;sortByDescendingMatches(<a href="../../algorithms/imageProcessing/TransformationPointFit.html" title="class in algorithms.imageProcessing">TransformationPointFit</a>[]&nbsp;fits,
                           int&nbsp;idxLo,
                           int&nbsp;idxHi)</pre>
<div class="block">sort the fits by descending number of matches.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>fits</code> - </dd><dd><code>idxLo</code> - </dd><dd><code>idxHi</code> - </dd></dl>
</li>
</ul>
<a name="createIntervals(double, double, double)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>createIntervals</h4>
<pre>double[]&nbsp;createIntervals(double&nbsp;start,
                       double&nbsp;stop,
                       double&nbsp;delta)</pre>
<div class="block">create an array of values starting with start and ending before stop
 with separations of size delta.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>start</code> - start of intervals, inclusive</dd><dd><code>stop</code> - end of intervals, exclusive</dd><dd><code>delta</code> - difference between returned sequential values</dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../algorithms/imageProcessing/NextContour.html" title="class in algorithms.imageProcessing"><span class="strong">Prev Class</span></a></li>
<li><a href="../../algorithms/imageProcessing/ScaleSpaceCurvature.html" title="class in algorithms.imageProcessing"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?algorithms/imageProcessing/PointMatcher.html" target="_top">Frames</a></li>
<li><a href="PointMatcher.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>

This is similar to a UML sequence diagram, but is drawn vertically instead
and the parameters which are tunable to improve the overall result are
starred on the left hand side.

The goal is to simplify the design where possible and optimize the 
parameters that affect the result.

   *  float cellFactor = 1.25f;
   *  float tolFactor = 0.5f;
   *  int dsNMaxIter = 50; 
   -- performVerticalPartitionedMatching
      -- performVerticalPartitionedMatching
         -- calcTransWithRoughGrid(s1, s2, w1, h1, w2, h2, f)
         |     
  *      | int rotDelat = 5; // w/ assignment to 2 for low point density 
  *      | int deltaTransX = 15; // w/ assignment to 50 for high point density   
  *      | int deltaTransY = 15; // w/ assignment to 50 for high point density
  *      | float tolTransX = getTolFactor() * deltaTransX;
  *      | float tolTransY = getTolFactor() * deltaTransY;
         |     
         |  -- calculateTransformationWithGridSearch(s1, s2, w1, h1, w2, h2,
         |  |  rotStart, rotStop, rotDelta, scaleStart, scaleStop, scaleDelta, 
         |  |  deltaTransX, deltaTransY, tolTransX, tolTransY, f)
         |  |
         |  |  List<TransformationPointFit> similarToBestFit;
         |  |
         |  |  for scale, rot:
         |  |  -- calculateTranslationForUnmatched0(s1, s2, w1, h1, w2, h2, r, s, f)
         |  |  |  int transXStart = -1*image2Width + 1;
         |  |  |  int transXStop = image2Width - 1;
         |  |  |  int transYStart = -1*image2Width + 1;
         |  |  |  int transYStop = image2Width - 1;
         |  |  |  -- calculateTranslationForUnmatched0(s1, s2, w1, h1, w2, h2, r, s, 
         |  |  |  |      txStart, txStop, tyStart, tyStop, nIntervals, tolTransX, tolTransY, f)
         |  |  |  |       
         |  |  |  |  fit = calculateTranslationFromGridThenDownhillSimplex(srs1, s1, s2, w1, h1, w2, h2, r, s,
         |  |  |  |  |   btxStart, btxStop, btxDelta, btyStart, btyStop, btyDelta, tolTransX, tolTransY, m, f)
         |  |  |  |  |              
         |  |  |  |  |  fits = evaluateTranslationsOverGrid(s1, s2, w1, h1, w2, h2, r, s, 
         |  |  |  |  |  |   btxStart, btxStop, btxDelta, btyStart, btyStop, btyDelta, tolTransX, tolTransY, m, f)
         |  |  |  |  |  |       
         |  |  |  |  |  |  TransformationPointFit[] evaluateTranslationsOverGrid(s1, s2, w1, h1, w2, h2, r, s,
         |  |  |  |  |  |  btxStart, btxStop, btxDelta, btyStart, btyStop, btyDelta, tolTransX, tolTransY, m, f, n)
         |  |  |  |  |  |                          
         |  |  |  |  |  |  float transX, transY;
         |  |  |  |  |  |       
         |  |  |  |  |  |  fits[count] = evaluateFitForUnMatchedTransformedOptimal(p,
         |  |  |  |  |  |           // = evaluateFitForUnMatchedTransformedGreedy(p,
         |  |  |  |  |  |                srs1, s2, tolTransX, tolTransY);
         |  |  |  |  |  |  return fits;
         |  |  |  |  |              
         |  |  |  |  |  refineTranslationWithDownhillSimplex            
         |  |  |  |  |              
         |  |  |  |  |return fit;
         |  |  |  |                     
         |  |  |  |return fit; 
         |  |  |  |// end calculateTranslationForUnmatched0
         |  |                           
         |  |  reevaluateFitsForCommonTolerance
         |  |                          
         |  |  if fitIsBetter 
         |  |      if converged
         |  |          finerGridSearchToDistinguishBest(similarToBestFit, s1, s2, w1, h1, w2, h2, f)
    *    |  |              int nIntervals = 3;
         |  |              finerGridSearch(nIntervals, fit, s1, s2, w1, h1, w2, h2, f)
         |  |                  double halfRange = 3 * fit.getMeanDistFromModel();
    *    |  |                  float tolTransX2 = fit.getTranslationXTolerance();
    *    |  |                  float tolTransY2 = fit.getTranslationYTolerance();
         |  |                  calculateTranslationFromGridThenDownhillSimplex(srs1, s1, s2, w1, h1, w2, h2,
         |  |                      r, s, txStart, txStop, txDelta, tyStart, tyStop, tyDelta, 
         |  |                      tolTransX, tolTransY, m, f)
         |  |              return bestFit
         |  |      else
    *    |  |          int nIntervals = 3;
         |  |          finerGridSearch(nIntervals, fit, s1, s2, w1, h1, w2, h2, f)
         |  |
         |  |   finerGridSearchToDistinguishBest(similarToBestFit, s1, s2, w1, h1, w2, h2, f)
         |  |   return bestFit

         -- refineTheTransformation

         reevaluateFitsForCommonTolerance

This is similar to a UML sequence diagram, but is drawn vertically instead
and the parameters which are tunable to improve the overall result are
starred on the left hand side.

The goal is to simplify the design where possible and optimize the 
parameters that affect the result.

   *  float cellFactor = 1.25f;
   *  float tolFactor = 0.5f;
   *  int dsNMaxIter = 50; 
   -- performVerticalPartitionedMatching
      -- performVerticalPartitionedMatching
         -- calcTransWithRoughGrid(s1, s2, w1, h1, w2, h2, f)
         |  -- calculateTransformationWithGridSearch(s1, s2, w1, h1, w2, h2,
         |  |  rotStart, rotStop, rotDelta, scaleStart, scaleStop, scaleDelta, f)
         |  |
   *     |  |  float tolTransX = generalTolerance;
   *     |  |  float tolTransY = generalTolerance;
         |  |  List<TransformationPointFit> similarToBestFit;
         |  |
         |  |  for scale, rot:
         |  |  -- calculateTranslationForUnmatched0(s1, s2, w1, h1, w2, h2, r, s, f)
         |  |  |  int transXStart = -1*image2Width + 1;
         |  |  |  int transXStop = image2Width - 1;
         |  |  |  int transYStart = -1*image2Width + 1;
         |  |  |  int transYStop = image2Width - 1;
         |  |  |  int transDeltaX = 4;
         |  |  |  int transDeltaY = 4;
   *     |  |  |  float tolTransX = tolFactor * transDeltaX
   *     |  |  |  float tolTransY = tolFactor * transDeltaY
         |  |  |  -- calculateTranslationForUnmatched0(s1, s2, w1, h1, w2, h2, r, s, 
         |  |  |  |      txStart, txStop, tyStart, tyStop, nIntervals, tolTransX, tolTransY, f)
         |  |  |  |       
         |  |  |  |  fit = calculateTranslationFromGridThenDownhillSimplex(srs1, s1, s2, w1, h1, w2, h2, r, s,
         |  |  |  |  |   btxStart, btxStop, btxDelta, btyStart, btyStop, btyDelta, tolTransX, tolTransY, m, f)
         |  |  |  |  |              
         |  |  |  |  |  fits = evaluateTranslationsOverGrid(s1, s2, w1, h1, w2, h2, r, s, 
         |  |  |  |  |  |   btxStart, btxStop, btxDelta, btyStart, btyStop, btyDelta, tolTransX, tolTransY, m, f)
         |  |  |  |  |  |       
         |  |  |  |  |  |  TransformationPointFit[] evaluateTranslationsOverGrid(s1, s2, w1, h1, w2, h2, r, s,
         |  |  |  |  |  |  btxStart, btxStop, btxDelta, btyStart, btyStop, btyDelta, tolTransX, tolTransY, m, f, n)
         |  |  |  |  |  |                          
         |  |  |  |  |  |  float transX, transY;
         |  |  |  |  |  |       
         |  |  |  |  |  |  fits[count] = evaluateFitForUnMatchedTransformedOptimal(p,
         |  |  |  |  |  |           // = evaluateFitForUnMatchedTransformedGreedy(p,
         |  |  |  |  |  |                srs1, s2, tolTransX, tolTransY);
         |  |  |  |  |  |  return fits;
         |  |  |  |  |              
         |  |  |  |  |return fit;
         |  |  |  |                     
         |  |  |  |return fit; 
         |  |  |  |// end calculateTranslationForUnmatched0
         |  |                           
         |  |  reevaluateFitsForCommonTolerance
         |  |                          
         |  |  if fitIsBetter 
         |  |      if converged
         |  |          finerGridSearchToDistinguishBest(similarToBestFit, s1, s2, w1, h1, w2, h2, f)
    *    |  |              int nIntervals = 3;
         |  |              finerGridSearch(nIntervals, fit, s1, s2, w1, h1, w2, h2, f)
         |  |                  double halfRange = 3 * fit.getMeanDistFromModel();
    *    |  |                  float tolTransX2 = fit.getTranslationXTolerance();
    *    |  |                  float tolTransY2 = fit.getTranslationYTolerance();
         |  |                  calculateTranslationFromGridThenDownhillSimplex(srs1, s1, s2, w1, h1, w2, h2,
         |  |                      r, s, txStart, txStop, txDelta, tyStart, tyStop, tyDelta, 
         |  |                      tolTransX, tolTransY, m, f)
         |  |              return bestFit
         |  |      else
    *    |  |          int nIntervals = 3;
         |  |          finerGridSearch(nIntervals, fit, s1, s2, w1, h1, w2, h2, f)
         |  |
         |  |   finerGridSearchToDistinguishBest(similarToBestFit, s1, s2, w1, h1, w2, h2, f)
         |  |   return bestFit

    *    int nTransIntervals = 3; 
         float transX = bestFit.getParameters().getTranslationX();
         float transY = bestFit.getParameters().getTranslationY();
    *    float dim = 2.5 * max(bestFit.tolerance)
         float gridWidth = nTransIntervals * dim;
         float gridHeight = nTransIntervals * dim;
    *    nTransIntervals = 9; 
    *    float tolTransX = dx;
    *    float tolTransY = dy;

         reevaluateFitsForCommonTolerance
